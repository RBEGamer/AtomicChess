\hypertarget{einleitung}{%
\section{Einleitung}\label{einleitung}}

\hypertarget{motivation}{%
\subsection{Motivation}\label{motivation}}

\begin{itemize}
\tightlist
\item
  Beginn: Er zieht die Aufmerksamkeit des Lesers durch die Schilderung
  des Ereignisses auf sich, das zu dem Problem geführt hat.
\item
  Hintergrundinformationen (Herstellung des Kontexts): Gehe tiefer auf
  das Ereignis ein, indem du mehr Informationen über es vermittelst und
  dabei auch den Rahmen deiner Forschung skizzierst.
\item
  Brücke zur Problemstellung: Erläutere, inwiefern es sich hierbei um
  ein Problem handelt, und schlage somit die Brücke zur Problemstellung,
  die deiner Untersuchung zu Grunde liegt.
\end{itemize}

\hypertarget{zielsetzung}{%
\subsection{Zielsetzung}\label{zielsetzung}}

Das Ziel dieser Arbeit ist es, einen autonomen Schachtisch zu
entwickeln, welcher in der Lage ist Schachfiguren autonom zu bewegen und
auf Benutzerinteraktion zu reagieren. Der Schwerpunkt liegt dabei
insbesondere auf der Programmierung des eingebetteten Systems und dem
Zusammenspiel von diesem mit einem aus dem Internet erreichbaren
Servers, welcher als Vermittlungsstelle zwischen verschiedenen
Schachtischen und anderen Endgeräten dient. Dieses besteht zum einem aus
der Positionserkennung und Steuerung der Hardwarekomponenten
(Schachfiguren) und zum anderen aus der Kommunikation zwischen dem Tisch
selbst und einem in einer Cloud befindlichem Server. Mittels der
Programmierung werden diverse Technologien von verschiedenen
Einzelsystemen zu einem Gesamtprodukt zusammengesetzt.

\hypertarget{methodik}{%
\subsection{Methodik}\label{methodik}}

Im ersten Abschnitt werden die zum Zeitpunkt existierenden Ansätze und
deren Umsetzung beleuchtet. Anschliessend werden die zuvor verwendeten
Technologien betrachtet, welche bei bei den beiden darauffolgenden
Prototypen verwendet wurden.

Das sechste Kapitel widmet sich der realisierung des erste Protoypen des
autonomen Schachtischs. Dabei werden alle Im anschliessenden Kapitel,
wird auf der Basis des ersten Prototyps und seiner auftretenden
Probleme, der finale Prototyp entwickelt. Hier werden die Probleme durch
ein re-design und vereinfachung der Elektronik gelößt und so ein
zufriedenstellendes Produkt entwickelt.

Im darauffolgenden Abschnitt wird die Cloud-Infrastruktur thematisiert,
welche für eine Kommunikation zwischen den Prototypen entscheidend ist.

\begin{itemize}
\tightlist
\item
  controller software
\item
  fazit
\end{itemize}

\hypertarget{analyse-bestehender-systeme-und-machbarkeitsanalyse}{%
\section{Analyse bestehender Systeme und
Machbarkeitsanalyse}\label{analyse-bestehender-systeme-und-machbarkeitsanalyse}}

\hypertarget{existierende-systeme-im-vergleich}{%
\subsection{Existierende Systeme im
Vergleich}\label{existierende-systeme-im-vergleich}}

\begin{itemize}
\tightlist
\item
  Nischenprodukt, jedoch einige Projekte im OpenSource bereich verfügbar
\item
  Ein kommerzieller Hersteller
\end{itemize}

\hypertarget{kommerzielle-produkte}{%
\subsubsection{Kommerzielle Produkte}\label{kommerzielle-produkte}}

\begin{longtable}[]{@{}lllll@{}}
\caption{Auflistung kommerzieller autonomer Schachtische}\tabularnewline
\toprule
\begin{minipage}[b]{0.18\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[b]{0.18\columnwidth}\raggedright
Square Off - Kingdom \cite{squareoffkingdom}\strut
\end{minipage} & \begin{minipage}[b]{0.22\columnwidth}\raggedright
Square Off - Grand Kingdom \cite{squareoffgrand}\strut
\end{minipage} & \begin{minipage}[b]{0.15\columnwidth}\raggedright
DGT Smart Board \cite{dtgsmartboard}\strut
\end{minipage} & \begin{minipage}[b]{0.13\columnwidth}\raggedright
DGT Bluetooth Wenge \cite{dtgble}\strut
\end{minipage}\tabularnewline
\midrule
\endfirsthead
\toprule
\begin{minipage}[b]{0.18\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[b]{0.18\columnwidth}\raggedright
Square Off - Kingdom \cite{squareoffkingdom}\strut
\end{minipage} & \begin{minipage}[b]{0.22\columnwidth}\raggedright
Square Off - Grand Kingdom \cite{squareoffgrand}\strut
\end{minipage} & \begin{minipage}[b]{0.15\columnwidth}\raggedright
DGT Smart Board \cite{dtgsmartboard}\strut
\end{minipage} & \begin{minipage}[b]{0.13\columnwidth}\raggedright
DGT Bluetooth Wenge \cite{dtgble}\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.18\columnwidth}\raggedright
Erkennung Figurstellung\strut
\end{minipage} & \begin{minipage}[t]{0.18\columnwidth}\raggedright
nein (Manuell per Ausgangsposition)\strut
\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
nein (Manuell per Ausgangsposition)\strut
\end{minipage} & \begin{minipage}[t]{0.15\columnwidth}\raggedright
ja\strut
\end{minipage} & \begin{minipage}[t]{0.13\columnwidth}\raggedright
ja\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.18\columnwidth}\raggedright
Abmessungen (LxBxH)\strut
\end{minipage} & \begin{minipage}[t]{0.18\columnwidth}\raggedright
486mm x 486mm x 75mm\strut
\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
671mm x 486mm x 75mm\strut
\end{minipage} & \begin{minipage}[t]{0.15\columnwidth}\raggedright
540mm x 540mm x 20mm\strut
\end{minipage} & \begin{minipage}[t]{0.13\columnwidth}\raggedright
540mm x 540mm x 20mm\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.18\columnwidth}\raggedright
Konnektivität\strut
\end{minipage} & \begin{minipage}[t]{0.18\columnwidth}\raggedright
Bluetooth\strut
\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
Bluetooth\strut
\end{minipage} & \begin{minipage}[t]{0.15\columnwidth}\raggedright
Seriell\strut
\end{minipage} & \begin{minipage}[t]{0.13\columnwidth}\raggedright
Bluetooth\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.18\columnwidth}\raggedright
Automatisches Bewegen der Figuren\strut
\end{minipage} & \begin{minipage}[t]{0.18\columnwidth}\raggedright
ja\strut
\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
ja\strut
\end{minipage} & \begin{minipage}[t]{0.15\columnwidth}\raggedright
nein\strut
\end{minipage} & \begin{minipage}[t]{0.13\columnwidth}\raggedright
nein\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.18\columnwidth}\raggedright
Spiel Livestream\strut
\end{minipage} & \begin{minipage}[t]{0.18\columnwidth}\raggedright
ja\strut
\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
ja\strut
\end{minipage} & \begin{minipage}[t]{0.15\columnwidth}\raggedright
ja\strut
\end{minipage} & \begin{minipage}[t]{0.13\columnwidth}\raggedright
ja\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.18\columnwidth}\raggedright
Cloud anbindung (online Spiele)\strut
\end{minipage} & \begin{minipage}[t]{0.18\columnwidth}\raggedright
ja (Mobiltelefon + App)\strut
\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
ja (Mobiltelefon + App)\strut
\end{minipage} & \begin{minipage}[t]{0.15\columnwidth}\raggedright
ja (PC + App)\strut
\end{minipage} & \begin{minipage}[t]{0.13\columnwidth}\raggedright
ja (PC + App)\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.18\columnwidth}\raggedright
Parkposition für ausgeschiedene Figuren\strut
\end{minipage} & \begin{minipage}[t]{0.18\columnwidth}\raggedright
nein\strut
\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
ja\strut
\end{minipage} & \begin{minipage}[t]{0.15\columnwidth}\raggedright
nein\strut
\end{minipage} & \begin{minipage}[t]{0.13\columnwidth}\raggedright
nein\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.18\columnwidth}\raggedright
Stand-Alone Funktionalität\strut
\end{minipage} & \begin{minipage}[t]{0.18\columnwidth}\raggedright
nein (Mobiltelefon erforderlich)\strut
\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
nein (Mobiltelefon erforderlich)\strut
\end{minipage} & \begin{minipage}[t]{0.15\columnwidth}\raggedright
nein (PC erforderlich)\strut
\end{minipage} & \begin{minipage}[t]{0.13\columnwidth}\raggedright
nein (PC erforderlich)\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.18\columnwidth}\raggedright
Besonderheiten\strut
\end{minipage} & \begin{minipage}[t]{0.18\columnwidth}\raggedright
Akku für 30 Spiele\strut
\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
Akku für 15 Spiele\strut
\end{minipage} & \begin{minipage}[t]{0.15\columnwidth}\raggedright
-\strut
\end{minipage} & \begin{minipage}[t]{0.13\columnwidth}\raggedright
-\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Bei den DGT-Schachbrettern ist zu beachten, dass diese die Schachfiguren
nicht autonom bewegen können. Sie wurden jedoch in die Liste
aufgenommen, da diese einen Teil der Funktionalitäten der Square Off
Schachbrettern abdecken und lediglich die automatische Bewegung der
Schachfiguren fehlt. Die DGT-Bretter können die Position der Figuren
erkennen und ermöglichen so auch Spiele über das Internet; diese können
sie auch als Livestream anbieten. Bei Schachturnieren werden diese für
die Übertragung der Partien sowie die Aufzeichnung der Spielzüge
verwendet und bieten Support für den Anschluss von weiterer Peripherien
wie z.B. Schachuhren.

Somit gibt es zum Zeitpunkt der Recherche nur einen Hersteller von
autonomen Schachbrettern, welcher auch die Figuren bewegen kann.

\hypertarget{open-source-projekte}{%
\subsubsection{Open-Source Projekte}\label{open-source-projekte}}

Bei allen Open-Source Projekten wurden die Features anhand der
Beschreibung und der aktuellen Software extrahiert. Besonders bei
work-in-progress Projekten können sich die Features noch verändern und
so weitere Funktionalitäten hinzugefügt werden.

Zusätzlich zu den genannten Projekten sind weitere derartige Projekte
verfügbar; in der Tabelle wurde nur jene aufgelistet, welche sich von
anderen Projekten in mindestens einem Feature unterscheiden.

Auch existieren weitere Abwandlungen von autonomen Schachbrettern, bei
welchem die Figuren von oberhalb des Spielbretts gegriffen bzw. bewegt
werden. In einigen Projekten wird dies mittels eines Industrie-Roboters
\cite{actprojectrobot} oder eines modifizierten
3D-Druckers\cite{atcproject3dprinter} realisiert. Diese wurden hier
aufgrund der Mechanik, welche über dem Spielbrett montiert werden muss,
nicht berücksichtigt.

\begin{longtable}[]{@{}llll@{}}
\caption{Auflistung von Open-Source Schachtisch
Projekten}\tabularnewline
\toprule
\begin{minipage}[b]{0.20\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[b]{0.24\columnwidth}\raggedright
Automated Chess Board (Michael Guerero) \cite{actproject1}\strut
\end{minipage} & \begin{minipage}[b]{0.26\columnwidth}\raggedright
Automated Chess Board (Akash Ravichandran) \cite{actproject2}\strut
\end{minipage} & \begin{minipage}[b]{0.19\columnwidth}\raggedright
DIY Super Smart Chessboard \cite{actproject3}\strut
\end{minipage}\tabularnewline
\midrule
\endfirsthead
\toprule
\begin{minipage}[b]{0.20\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[b]{0.24\columnwidth}\raggedright
Automated Chess Board (Michael Guerero) \cite{actproject1}\strut
\end{minipage} & \begin{minipage}[b]{0.26\columnwidth}\raggedright
Automated Chess Board (Akash Ravichandran) \cite{actproject2}\strut
\end{minipage} & \begin{minipage}[b]{0.19\columnwidth}\raggedright
DIY Super Smart Chessboard \cite{actproject3}\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.20\columnwidth}\raggedright
Erkennung Figurstellung\strut
\end{minipage} & \begin{minipage}[t]{0.24\columnwidth}\raggedright
nein (Manuell per Ausgangsposition)\strut
\end{minipage} & \begin{minipage}[t]{0.26\columnwidth}\raggedright
ja (Kamera / OpenCV)\strut
\end{minipage} & \begin{minipage}[t]{0.19\columnwidth}\raggedright
nein\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
Abmessungen (LxBxH)\strut
\end{minipage} & \begin{minipage}[t]{0.24\columnwidth}\raggedright
keine Angabe\strut
\end{minipage} & \begin{minipage}[t]{0.26\columnwidth}\raggedright
keine Angabe\strut
\end{minipage} & \begin{minipage}[t]{0.19\columnwidth}\raggedright
450mm x 300mm x 50mm\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
Konnektivität\strut
\end{minipage} & \begin{minipage}[t]{0.24\columnwidth}\raggedright
\gls{usb}\strut
\end{minipage} & \begin{minipage}[t]{0.26\columnwidth}\raggedright
\gls{wlan}\strut
\end{minipage} & \begin{minipage}[t]{0.19\columnwidth}\raggedright
\gls{wlan}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
Automatisches Bewegen der Figuren\strut
\end{minipage} & \begin{minipage}[t]{0.24\columnwidth}\raggedright
ja\strut
\end{minipage} & \begin{minipage}[t]{0.26\columnwidth}\raggedright
ja\strut
\end{minipage} & \begin{minipage}[t]{0.19\columnwidth}\raggedright
nein\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
Spiel Livestream\strut
\end{minipage} & \begin{minipage}[t]{0.24\columnwidth}\raggedright
nein\strut
\end{minipage} & \begin{minipage}[t]{0.26\columnwidth}\raggedright
nein\strut
\end{minipage} & \begin{minipage}[t]{0.19\columnwidth}\raggedright
nein\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
Cloud anbindung (online Spiele)\strut
\end{minipage} & \begin{minipage}[t]{0.24\columnwidth}\raggedright
nein\strut
\end{minipage} & \begin{minipage}[t]{0.26\columnwidth}\raggedright
nein\strut
\end{minipage} & \begin{minipage}[t]{0.19\columnwidth}\raggedright
ja\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
Parkposition für ausgeschiedene Figuren\strut
\end{minipage} & \begin{minipage}[t]{0.24\columnwidth}\raggedright
nein\strut
\end{minipage} & \begin{minipage}[t]{0.26\columnwidth}\raggedright
nein\strut
\end{minipage} & \begin{minipage}[t]{0.19\columnwidth}\raggedright
nein\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
Stand-Alone Funktionalität\strut
\end{minipage} & \begin{minipage}[t]{0.24\columnwidth}\raggedright
nein (PC erforderlich)\strut
\end{minipage} & \begin{minipage}[t]{0.26\columnwidth}\raggedright
ja\strut
\end{minipage} & \begin{minipage}[t]{0.19\columnwidth}\raggedright
ja\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
Besonderheiten\strut
\end{minipage} & \begin{minipage}[t]{0.24\columnwidth}\raggedright
-\strut
\end{minipage} & \begin{minipage}[t]{0.26\columnwidth}\raggedright
Sprachsteuerung (Amazon Alexa)\strut
\end{minipage} & \begin{minipage}[t]{0.19\columnwidth}\raggedright
Zuganzeige über LED Matrix\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
Lizenz\strut
\end{minipage} & \begin{minipage}[t]{0.24\columnwidth}\raggedright
\gls{gpl} 3+\strut
\end{minipage} & \begin{minipage}[t]{0.26\columnwidth}\raggedright
\gls{gpl}\strut
\end{minipage} & \begin{minipage}[t]{0.19\columnwidth}\raggedright
-\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

In den bestehenden Projekten ist zu erkennen, dass ein autonomer
Schachtisch sehr einfach und mit simplen Mittel konstruiert werden kann.
Hierbei fehlen in der Regel einige Features, wie das automatische
Erkennen von Figuren oder das Spielen über das Internet.

Einige Projekte setzten dabei auf eingebettete Systeme, welche direkt im
Schachtisch montiert sind, andere hingegen nutzen einen externen PC,
welcher die Steuerbefehle an die Elektronik sendet.

Bei der Konstruktion der Mechanik und der Methode mit welcher die
Figuren über das Feld bewegt werden ähneln sich jedoch die meisten
dieser Projekte. Hier wird in der Regel eine einfache X- und Y-Achse
verwendet, welche von zwei Schrittmotoren bewegt werden. Die
Schachfiguren werden dabei mittels eines Elektromagneten über die
Oberseite gezogen. Hierbei ist ein Magnet oder eine kleine Metallplatte
in den Fuß der Figuren eingelassen worden.

Die Erkennung der Schachfiguren ist augenscheinlich die schwierigste
Aufgabe. Hier wurde in der Mehrzahl der Projekte eine Kamera im
Zusammenspiel mit einer auf OpenCV basierenden Figur-Erkennung
verwendet. Diese Variante ist je nach Implementierung des
Vision-Algorithmus fehleranfälliger bei sich ändernden
Lichtverhältnissen, auch muss die Kamera oberhalb der Schachfiguren
platziert werden, wenn kein transparentes Schachfeld verwendet werden
soll.

Eine weitere Alternative ist die Verwendung einer Matrix aus
Reed-Schaltern oder Halleffekt-Sensoren. Diese werden in einer 8x8
Matrix Konfiguration unterhalb der Platte montiert und reagieren auf die
Magnete in den Figuren. So ist es möglich zu erkennen, welches der
Schachfelder belegt ist, jedoch nicht konkret von welchem Figurtypen.
Dieses Problem wird durch eine definierte Ausgangsstellung beim
Spielstart gelöst. Nach jedem Zug durch den Spieler und der dadurch
resultierenden Änderungen in der Figurpositionen in der Matrix können
die neuen Figurstellungen berechnet werden.

\hypertarget{user-experience}{%
\subsection{User Experience}\label{user-experience}}

Ein wichtiger Aspekt bei diesem Projekt stellt die User-Experience dar.
Diese beschreibt die Ergonomie der Mensch-Maschine-Interaktion und wird
durch die DIN 9241\cite{din9241} beschrieben. Hierbei geht es primär
um das Erlebnis, welches der Benutzer bei dem Verwenden eines Produktes
erlebt und welche Erwartungen der Benutzer an die Verwendung des
Produktes hat.

Bei dem autonomen Schachtisch, soll der Benutzer eine ähnlich
authentische Erfahrung erleben wie bei einer Schachpartie mit einem
menschlichen Gegenspieler. Der Benutzer soll direkt nach dem Einschalten
des Tisches und dem Aufstellen der Figuren in der Lage sein, mit dem
Spiel beginnen zu können. Dies soll wie ein reguläres Schachspiel
ablaufen; der Spieler vor dem Tisch soll die Figuren mit der Hand
bewegen können und der Tisch soll den Gegenspieler darstellen. Dieser
bewegt die Figuren der Gegenseite.

Nach Beendigung einer Partie, soll das Spielbrett wieder in die
Ausgangssituation gebracht werden; dies kann zum einem vom Tisch selbst
oder vom Benutzer manuell geschehen. Danach ist der Tisch für die
nächste Partie bereit, welche einfach per Knopfdruck gestartet werden
können sollte.

Dies soll auf für abgebrochene Spiele gelten, welche von Benutzer oder
durch das System abgebrochen werden. Hierbei soll das Schachbrett sich
ebenfalls selbständig zurücksetzten können.

Ein weiter Punkt welcher bei der User-Experience beachtet werden soll,
ist die zeitliche Konstante. Ein Spiel auf einem normalen Schachspiel
hat je nach Spielart kein Zeitlimit, dies kann für das gesamte Spiel
gelten oder auch für die Zeit zwischen einzelnen Zügen. Der autonome
Schachtisch soll es dem Spieler z.B. ermöglichen ein Spiel am Morgen zu
beginnen und dieses erst am nächsten Tag fortzusetzen.

Auch muss sich hier die Frage gestellt werden, was mit den
ausgeschiedenen Figuren geschieht. Bei den autonomen Schachbrettern von
Square Off\cite{squareoffgrand}, werden die Figuren an die Seite auf
vordefinierte Felder bewegt und können so wieder bei der nächsten Partie
vom System aufgestellt werden. Viele andere Projekte schieben die
Figuren auf dem Feld heraus, können diese aber im Anschluss nicht mehr
gezielt in das Feld zurückholen. So muss diese Aufgabe vom Benutzer
geschehen. Auch wir diese Funktionalität von einigen Projekten nicht
abgedeckt und der Benutzer muss die Figuren selbständig vom Feld
entfernen.

\hypertarget{anforderungsanalyse}{%
\subsection{Anforderungsanalyse}\label{anforderungsanalyse}}

\begin{itemize}
\tightlist
\item
  komplettes vollweriges Produkt
\end{itemize}

\begin{longtable}[]{@{}ll@{}}
\caption{Auflistung der Anforderungen an den autonomen
Schachtisch}\tabularnewline
\toprule
& \gls{atc} -- autonomous Chessboard\tabularnewline
\midrule
\endfirsthead
\toprule
& \gls{atc} -- autonomous Chessboard\tabularnewline
\midrule
\endhead
Erkennung Schachfigurstellung & ja\tabularnewline
Konnektivität & \gls{wlan}, \gls{usb}\tabularnewline
Automatisches Bewegen der Figuren & ja\tabularnewline
Spiel Livestream & ja\tabularnewline
Cloud anbindung (online Spiele) & ja\tabularnewline
Parkposition für ausgeschiedene Figuren & ja\tabularnewline
Stand-Alone Funktionalität & ja (Bedienung direkt am
Tisch)\tabularnewline
Besonderheiten & visuelle Hinweise per Beleuchtung\tabularnewline
\bottomrule
\end{longtable}

Die Abmessungen und das Gewicht des autonomen Schachtisches, ergeben
sich aus mechanischen Umsetzung und werden hier aufgrund der zur
Verfügung stehenden Materialen und fertigungstechniken nicht festgelegt.
Dennoch wird Wert darauf gelgegt, dass das Verhältnis zwischen den
Spielfeldabmessungen und den Abmessungen des Tisches so gering wie
möglich ausfällt. Auch müssen die Figuren für den Benutzer eine gut
handhabbare Grösse aufweisen um ein angenehmes haptisches Spielerlebnis
zu gewährleisten.

\begin{itemize}
\tightlist
\item
  abmessungen und gewicht ergeben sich aus der Umsetzung der
  Anforderungen
\end{itemize}

\hypertarget{technologien-im-makerspace}{%
\subsubsection{Technologien im
Makerspace}\label{technologien-im-makerspace}}

\begin{itemize}
\tightlist
\item
  stehen diese im makerspace zur verfüfung
\end{itemize}

\hypertarget{machbarkeitsanalyse}{%
\subsection{Machbarkeitsanalyse}\label{machbarkeitsanalyse}}

\begin{itemize}
\tightlist
\item
  welche technologien werden benötigt
\item
  software architektur anfoderungen
\item
  hardware anforderungen
\item
  grosse
\item
  wiederholgenauigkeit
\item
  lautstärke
\item
  vorerfahrnung in cad ed druck und schaltungsdesign
\end{itemize}

\hypertarget{grundlegende-verifikation-der-ausgewuxe4lten-technologien}{%
\section{Grundlegende Verifikation der ausgewälten
Technologien}\label{grundlegende-verifikation-der-ausgewuxe4lten-technologien}}

\hypertarget{erprobung-buildroot-framework}{%
\subsection{Erprobung
Buildroot-Framework}\label{erprobung-buildroot-framework}}

\begin{itemize}
\tightlist
\item
  erstellen eines einfachen images für das embedded System
\item
  inkl ssh Server und SFTP
\item
  qt 5 libraries
\item
  eigenes package atctp
\item
  test der toolchain
\end{itemize}

\hypertarget{verifikfation-nfc-technologie}{%
\subsection{Verifikfation NFC
Technologie}\label{verifikfation-nfc-technologie}}

\begin{itemize}
\tightlist
\item
  warum gewählter nfc reader =\textgreater{} ndef lesen
\item
  reicheweiten test mit 22mm
\item
  test mit benachbarten figuren
\item
  warum kein RFID =\textgreater{} keine speicherung von id auf der
  controller seite
\item
  selbherstellung von eigenen figuren ohne modifikation der
  controllerseite
\end{itemize}

\begin{figure}
\centering
\includegraphics{images/ATC_nfc_range_test.png}
\caption{Grove PN532 NFC Reader mit Kabelgebundener Antenne
\label{ATC_nfc_range_test}}
\end{figure}

\begin{itemize}
\tightlist
\item
  test mit figuren nebeneinander
\end{itemize}

\hypertarget{schrittmotor-schrittmotorsteuerung}{%
\subsection{Schrittmotor /
Schrittmotorsteuerung}\label{schrittmotor-schrittmotorsteuerung}}

\begin{itemize}
\tightlist
\item
  warum =\textgreater{} einfache ansteuerung
\item
  keine STEP DIR somit muss embedded nicht echtzeitfähigsein und kann
  ggf auch andere task abbarbeiten
\item
  TMC schrittmotortreiber spi configuration
\item
  und goto move =\textgreater{} wait for move finished irw testen
\item
  dafür einfacher python testreiber geschribene
\item
  schrittverlust nicht zu erwarten
\end{itemize}

\hypertarget{d-druck-fuxfcr-den-mechanischen-aufbau}{%
\subsection{3D Druck für den mechanischen
Aufbau}\label{d-druck-fuxfcr-den-mechanischen-aufbau}}

Da es sich hier nur um einen Protoypen handelt, wurde hier auf ein
einfach zu handbabendes Filament vom Typ PLA verwendet. Dies ist
besonders gut für die Prototypenendwicklung geeignet und kann mit nahezu
jeden handelsüblichen \gls{fdm} 3D-Drucker verarbeitet werden.

Zuvor wurden einige Testdrucke durchgeführt um die Qualität der zuvor
gewählten Druckparameter zu überprüfen und diese gegebenenfalls
anzupassen. Auch wurden verschiedene Calibrierobjekte gedruckt, an
welchen die Toleranzen für die späteren \gls{cad} Zeichnungen abgeschätz
werden können.

Dies betrifft vor allem die Genuigkeit der Bohrungen in den gefertigten
Objekten, da hier später Bolzen und Schrauben ein nahezu spielfrei
eingeführt werden müssen. Ein Test, welcher die Machbarkeit von Gewinden
zeigt wurde nicht durchgeführt, da alle Schrauben später mit der
passenden Mutter gesichert werden sollen. So soll eine Abnutzung durch
häufige Montage der gedruckten Bauteile verhindert werden.

Bei dem Design der zu druckenden Bauteile wurde darauf geachtet, dass
diese den Bauraum von 200x200x200mm nicht überschreiten und somit auch
von einfachen \gls{fdm} 3D-Druckern verarbeitet werden können.

Als Software wurde der Open-Source Slicer Ultimaker Cura
\cite{ultimakercura} verwendet, da dieser zum einen bereits fertige
Konfigurationen für den verwendeten 3D-Drucker enhält und zum anderen
experimentelle Features bereitstellt.

\begin{figure}
\centering
\includegraphics{images/3d_print_tree_structure.png}
\caption{3D Druck: Objekt (rot,gelb,grün),Tree Structure (cyan)
\label{3d_print_tree_structure}}
\end{figure}

Hier wurde für die Bauteile, welche eine Sützstruktur benötigen, die von
Cura bereitgestellte Tree Support Structure aktiviert.
\ref{3d_print_tree_structure} Diese bietet den Vorteil gegenüber anderen
Stützstruktiren, dass sich diese leichter entfernen lässt und weniger
Rückstände an den Bauteilen hinterlässt. Diese Vorteile wurde mit
verschiedenen Testdrucken verifiziert und kommen insbesondere bei
komplexen Bauteilen mit innenliegenden Elementen zum tragen bei denen
eine Stützstruktur erfoderlich sind.

\begin{longtable}[]{@{}ll@{}}
\caption{Verwendete 3D Druck Parameter. Temperatur nach
Herstellerangaben des verwendeten PLA Filaments.}\tabularnewline
\toprule
Ender 3 Pro 0.4mm Nozzle & PLA Settings\tabularnewline
\midrule
\endfirsthead
\toprule
Ender 3 Pro 0.4mm Nozzle & PLA Settings\tabularnewline
\midrule
\endhead
Layer Height & 0.2mm\tabularnewline
Infill & 50.00\%\tabularnewline
Wall Thickness & 2.0mm\tabularnewline
Support Structure & Tree\tabularnewline
Top Layers & 4\tabularnewline
Bottom Layers & 4\tabularnewline
\bottomrule
\end{longtable}

\begin{itemize}
\tightlist
\item
  Zeit für den 3D Druck Prozess spiel hier keine Rolle, da selbstbau
  projekt
\item
  Parameter lassen sich weiter anpassen z.B. Layerheight auf 0.4
\item
  finaler protoyp bietet sich abs oder pteg an
\end{itemize}

\hypertarget{erstellung-erster-prototyp}{%
\section{Erstellung erster Prototyp}\label{erstellung-erster-prototyp}}

\begin{itemize}
\item
  proof of conzept
\item
\end{itemize}

\begin{figure}
\centering
\includegraphics{images/table_images/dk.png}
\caption{Prototyp Hardware: Erster Prototyp des autonomen Schachtisch
\label{dk}}
\end{figure}

\hypertarget{mechanik}{%
\subsection{Mechanik}\label{mechanik}}

\begin{itemize}
\tightlist
\item
  vorgaben IKEA tisch als grundbasis =\textgreater{} bereits fertiger
  grundrahmen in denen die einzelteile integriert werden können
\item
  xy riemen führung
\item
  spiel in Mechanik
\item
  Einabrietung in Fusion360
\item
  Cad design aller bauteile
\item
  standartxy
\item
  erweituerng des spielraums durch zwei Magnete
\end{itemize}

\hypertarget{parametrisierung-schachfiguren}{%
\subsection{Parametrisierung
Schachfiguren}\label{parametrisierung-schachfiguren}}

Da das System die auf dem Feld befindlichen Schachfiguren anhand von
\gls{nfc} Tags erkennt, müssen diese zuerst mit Daten beschrieben
werden. Die verwendeten NXP NTAG 21 Chips, besitzen einen vom Benutzer
verwendbaren Speicher von 180 Byte. Dieser kann über ein
\gls{nfc}-Lese/Schreibgerät mit Daten verschiednster Art beschrieben und
wieder ausgelesen werden. Moderne Mobiltelefone besitzen in der Regel
auch die Fähigkeit mit passenden \gls{nfc} Tags kommunizieren zu können;
somit sind keine Stand-Alone Lesegeräte mehr notwendig.

Der Schachtisch verwendet dabei das \gls{ndef} Dateiformat welches
Festlegt, wie die Daten auf dem \gls{nfc} Tag gespeichert werden. Da
diesen ein Standatisiertes Format ist, können alle gängigen Lesegeräte
und Chipsätze diese Datensätze lesen. Der im autonomen Schachtisch
verwendete Chipsatz PN532 von NXP ist dazu ebenfalls in der Lage.

Um das \gls{ndef} Format verwenden zu können, müssen die \gls{nfc} Tags
zuerst auf diese Formatiert werden. Die mesten käuflichen Tags sind
bereits derart formatiert. Alternativ kann dies mittels Mobiltelefon und
passender App geschehen. Da \gls{ndef} Informationen über die
Formatierung und der gepeicherten Einträge speichert, stehen nach der
Formatierung nur noch 137 Bytes des NXP NTAG 21 zur verfügung.

Per Lesegerät können anschliessend mehrere \gls{ndef} Records auf den
Tag geschrieben werden. Diese sind mit Dateien auf einer Festplatte
vergleichbar und können verschiedenen Dateiformate und Dateigrössen
annehmen. Ein typischer Anwendungsfall ist der \gls{ndefrtd} URL
Datensatz. Dieser kann dazu genutzt werden eine spezifizierte URL auf
dem Endgeräte aufzurufen, nachdem der \gls{nfc} Tag gescant
wurde.\cite{nordicnfclibndef}

Der autonome Schachtisch verwendet den einfachsten \gls{ndefrtd} Typ,
welcher der Text-Record ist, und zum speichern von Zeichenketten genutzt
werden kann, ohne das eine Aktion auf dem Endgerät ausgeführt wird.
Jeder Tag einer Schafigur, welche für den autonomen Schachtisch
verwendet werden kann, besitzt diesen \gls{ndef} Record an der ersten
Position. Alle weiteren eventuell vorhandenen Records werden vom Tisch
ignoriert.\cite{nordicnfclib}

\begin{figure}
\centering
\includegraphics{images/ATC_ChessFigureIDGenerator.png}
\caption{Prototyp Hardware: Tool zur Erstellung des NDEF Payloads:
ChessFigureIDGenerator.html \label{ATC_ChessFigureIDGenerator}}
\end{figure}

Um die Payload für den \gls{nfc} Record zu erstellen wurde ein kleine
Web-Applikation erstellt, welche den Inhalt der Text-Records erstellt.
Dieser ist für jede Figur individuell und enthält den Figur-Typ und die
Figur-Farbe. Das Tool untersützt auch das Speichern weiterer Attribute
wie einem Figur-Index, welcher aber in der finalen Software-Version
nicht genutzt wird. \ref{ATC_ChessFigureIDGenerator}

Nach dem Beschreiben eines \gls{nfc} Tags ist es möglich diesen gegen
auslesen oder erneuten Schreiben mittels einer Read/Write-Protection zu
schützen. Diese Funktionalität wird nicht verwendet um das Kopieren von
Figuren durch den Benutzer zu ermöglichen. Somit kann dieser leicht
seine eigenen Figuren erschaffen, ohne auf das Tool angewiesen zu sein.
Auch ist es möglich verschiedene Figur-Sets zu mischen, so kann jeder
Spieler sein eigenes Set an Figuren mit dem autonomen Schachtisch
verwenden.

\begin{figure}
\centering
\includegraphics{images/ndef_record_rook.png}
\caption{Prototyp Hardware: NDEF Text Record Payload für einen weissen
Turm \label{ndef_record_rook}}
\end{figure}

\hypertarget{schaltungsentwurf}{%
\subsection{Schaltungsentwurf}\label{schaltungsentwurf}}

\begin{figure}
\centering
\includegraphics{images/ATC_Hardware_Architecture_DK.png}
\caption{Prototyp Hardware: Blockdiagramm
\label{ATC_Hardware_Architecture_DK}}
\end{figure}

\begin{itemize}
\tightlist
\item
  auswahl der Motortreiber (leise, bus ansteuerung)
\item
  ansteuerung pn532 und umsetzung auf uart
\item
  platinendesign
\item
  ansterung elektromagnetet
\end{itemize}

\hypertarget{implementierung-hal}{%
\subsubsection{Implementierung HAL}\label{implementierung-hal}}

\begin{itemize}
\tightlist
\item
  ansteuerung des TMC5160
\item
  ansterung des Microncontollers (PN532, LED)
\item
  integration in controller software
\item
  welche funktion stehen bereit tabelle
\end{itemize}

\hypertarget{fazit-zum-ersten-prototypen}{%
\subsection{Fazit zum ersten
Prototypen}\label{fazit-zum-ersten-prototypen}}

\begin{itemize}
\tightlist
\item
  nicht für production geeignet
\item
  aufbau und calibrierung langwiehrig
\item
  trotzdem robustes design auf kleinem formfaktor
\item
  verwendeten elektromagnete nicht stark genug, somit über aqusserhalb
  der specs betrieben was zu temeraturproblemen führte
\item
  gewicht der Figuren zu klein bzw magnete zu start
\item
  workarounds in der software nötig durch die beiden magnete
\item
  nicht die beste entscheidung direkt auf grösse zu optimieren
\end{itemize}

\hypertarget{erstellung-zweiter-prototyp}{%
\section{Erstellung zweiter
Prototyp}\label{erstellung-zweiter-prototyp}}

\begin{figure}
\centering
\includegraphics{images/table_images/prod.png}
\caption{Producation Hardware: Finaler autonomer Schachtisch
\label{prod}}
\end{figure}

\hypertarget{modifikation-der-mechanik}{%
\subsection{Modifikation der Mechanik}\label{modifikation-der-mechanik}}

\begin{itemize}
\tightlist
\item
  dauertest hat gezeigt dass mechnik zu viel spiel aufweisst
\item
  Motorenhalterung der y achse schränkt des bewegungsspielraum um mehr
  als 10cm ein, welches zu einem unwesentlichen grösseren verhältnis von
  Spielfeldgrösse und Abmessungen des Schachtischs
\item
  CoreXY bietet Vorteil:
\item
  Motoren fest am rahmen =\textgreater{} weniger kabel + gewicht an der
  Y Achse
\item
  jedoch komplexerer Aufwand der riemenverlegung so komplexere 3d
  bauteile
\item
  Tischabmessungen 620x620mm dabei Bewegungsspielraum vom 580x580 zuvor
  nur 480x480
\end{itemize}

\hypertarget{optimierungen-der-spielfiguren}{%
\subsection{Optimierungen der
Spielfiguren}\label{optimierungen-der-spielfiguren}}

Die bisherigen genutzen vorgefertigten Figuren funktionierten mit dem
ersten Prototyp problemlos. Sie wiesen aber trotzdem eine zu hohe
Fehleranfälligkeit, im Bezug auf das gegenseitige Beeinflussen
(abstoßen,anziehen) durch die verwendeten Magnete.

Die größse der Figuren kann durch die fest definierte Feldgrösse von
55mm und der verwendeten \gls{nfc} Tags nicht verändert werden. Nach
vielen Testdurchläufen mit dem ersten Prototyp war zu erkennen, dass
sich die Figuren je nach aktueller Situation auf dem Spielfeld immernoch
magnetisch anziehen. Dies führt je nach Spielverlauf zu Komplikationen,
sodass die Figuren manuell wieder mittig auf den Felder platziert werden
müssen.

Um dies zu verhindern, wurde einige Figuren zusätzlich mit einer 20mm
Unterlegscheibe am Boden versehen, welche diese Problem behob, jedoch
das \gls{nfc} Tag nicht mehr als lesbar erwies. Dies resultierte in der
Idee die Schachfiguren ebenfalls selbst mit dem 3D-Drucker herzustellen
und die Magnete direkt in den Boden der Figur einlassen zu können.

Die aktuell verwendeten Figuren des ersten Protoyp wiegen 8 Gramm für
die Bauern und 10 Gramm für die restlichen Figuren. Der Test mit der
Unterlegscheibe ergab, dass diese mit 4 Gramm genug Gewicht hinzufügte
um die magnetische Beeinflussung zu unterbinden.

Testweise wurden eingie Figuren mittels 3D Drucker erstellt um so das
Gewicht zu erhöhen. Nach einem erfolgreichen Test wurde das \gls{cad}
Modell wurde so angepasst, dass sich der Magnet direkt in den Boden der
Figure einkleben lässt. Desweiteren wurden bei den Bauern (den
leichtesten) Figuren die Magnete ausgetauscht. Die zuerst verwendeten
10x3mm Neodym-Magnete wurden bei diesen Figuren gegen 6x3mm Magnete
getauscht. Somit sind im Design zwei verschiedenen Arten von Magneten
notwendig, jedoch traten in den anschliessend durchgeführten Testläufen
keine Beeinflussungen mehr statt.

\hypertarget{uxe4nderungen-der-elektronik}{%
\subsection{Änderungen der
Elektronik}\label{uxe4nderungen-der-elektronik}}

Mit ein grösserer Kritikpunkt, welcher bereits wärend des Aufbaus des
ersten Protoyps zu erkennen war, ist die Umsetzunge der Elektronik.
Diese wurde im ersten Prototyp manuell Aufgebaut und enthielt viele
verschiedene Komponenten.

Die verwendeten Motortreiber stellten sich wärend der Entwicklung als
sehr felxibel heraus, stellten aber auch einen grossen Kostenfaktor dar.
Nach dem Aufbau und erprobung des ersten Prototyps wurde ersichtlich,
dass hier nicht alle zuerst angedachten Features der Treiber benötigt
werden und so auch andere alternativen in Frage kommen. Zusätzlich
konnte die Elektronik nur beschränkt mit anderen System verbunden
werden, welches insbesondere durch die verwendete \gls{spi}
Schnittstelle geschuldet war.

All diese Faktoren erschweren einen einfachen Zusammenbau des autonomen
Schachtischs. Die Lösung stellt die Verwendung von Standardhardware dar.
Nach dem Herunterbrechen der elektrischen Komponenten und des
mechanischen Aufbaus ist zu erkennen, dass der autonome Schachtisch
einer CNC-Fräse bzw eines 3D Drucker ähnelt. Insbesondere die XY-Achsen
Mechanik sowie die ansteuerung von Schrittmotoren, wird in diesen
Systemen verwendet. Mit den Druchbruch von 3D Druckern im
Consumerbereich, sind auch kleine Steuerungen, preisgünstige Steuerungen
erhältlich, welche 2-3 Schrittmotoren und einiges anzusätzlicher
Hardware ansteuern können.

\begin{longtable}[]{@{}llll@{}}
\caption{Standardhardware 3D Drucker Steuerungen}\tabularnewline
\toprule
& SKR 1.4 Turbo & Ramps 1.4 & Anet A8 Mainboard\tabularnewline
\midrule
\endfirsthead
\toprule
& SKR 1.4 Turbo & Ramps 1.4 & Anet A8 Mainboard\tabularnewline
\midrule
\endhead
Stepper Driver & TMC2209 & A4988 / TMC2209 & A4988\tabularnewline
LED Strip Port & WS2811 / RGB & - & -\tabularnewline
Firmware & Marlin-FW 2.0 & Marlin-FW 1.0 & Proprietary\tabularnewline
\bottomrule
\end{longtable}

Hierbei existiert eine grosse Auswahl dieser mit den verschiensten
Ausstattungen. Bei der Aufwahl dieser wurde vorallem auf die Möglichkeit
geachtet sogenannte Silent-Schrittmotortreiber verwenden zu können um
die Geräuschimmissionen durch die Motoren soweit wie möglich zu
minimieren. Im ersten Protoyp wurde unter anderem aus diesem Grund die
TMC5160-BOB Treiber ausgewählt. Hierzu wurde der Schrittmotor-Treiber
TMC2209 gewält, welcher diese Features ebenfalls untersützt und in der
Variante als Silent-Step-Stick direkt in die meisten 3D Drucker
Steuerungen eingesetzt werden können. Hierbei ist es wichtig, dass auf
der gewählten Steuerung die Treiber-ICs nicht fest verlötet sind,
sondern getauscht werden können. Ein weitere Punkt ist die Kommunikation
der Steuerung mit dem Host-System. Hierbei setzten alle untersuchten
Steuerungen auf die \gls{usb} Schnittstelle und somit ist eine einfache
Kommunikation gewährleistet. Das verwendete eingebette System im
autonomen Schachtisch bietet vier freie \gls{usb} Anschlüsse, somit ist
eine einfache Integration gewärleistet.

\begin{figure}
\centering
\includegraphics{images/ATC_Hardware_Architecture_PROD.png}
\caption{Producation Hardware: Blockdiagramm
\label{ATC_Hardware_Architecture_PROD}}
\end{figure}

Nach einer gründlichen Evaluation der zur verfügung stehenden
Steuerungen, wurde die SKR 1.4 Turbo Steuerung ausgewählt, da diese
trotz des etwas höheren Marktpreises genug Ressourcen auch für spätere
Erweiterung bietet und eine Unterstüzung für die neuste Version der
Marlin-FW\cite{marlinfw} bereitstellt. Somit wurde die Elektronik
durch die verwendete Plug\&Play stark vereinfacht
\ref{ATC_Hardware_Architecture_PROD}.

\hypertarget{hal-implementierung-gcode-sender}{%
\subsubsection{HAL: Implementierung
GCODE-Sender}\label{hal-implementierung-gcode-sender}}

Durch die durchgeführten Änderungen an der Elektronik insbesondere durch
die Verwendung einer Marlin-FW\cite{marlinfw} fähigen
Motorsteuerung, ist eine Anpassung der \gls{hal} notwendig. Diese
unterzützt die Ansteuerung der Motoren und anderen Komponenten (z.B.
Spindeln, Heizelemente) mittels G-Code und wird typischerweise in 3D
Druckern und CNC-Fräsen eingesetzt. G-Code ist eine
Marlin-FW\cite{marlinfw} biete dabei einen großen Befehlssatz an
G-Code Kommandos an. Bei diesem Projekt werden jedoch nur einige G-Code
Kommandos verwendet, welche sich insbesondere auf die Ansteuerung der
Motoren beschränken.

\begin{longtable}[]{@{}lll@{}}
\caption{Grundlegende verwendete G-Code Kommandos}\tabularnewline
\toprule
& G-Code Command & Parameters\tabularnewline
\midrule
\endfirsthead
\toprule
& G-Code Command & Parameters\tabularnewline
\midrule
\endhead
Move X Y & G0 & X Y\tabularnewline
Move Home Position & G28 &\tabularnewline
Set Units to Millimeters & G21 &\tabularnewline
Set Servo Position & M280 & P S\tabularnewline
Disable Motors & M84 & X Y\tabularnewline
\bottomrule
\end{longtable}

Die erforderlichen Kommandos wurden auf eine Minimum beschränk um eine
maximale Komaptibilität bei verschiedenen G-Code fähigen Steuerungen zu
gewährleisten. Die Software unterstützt jedoch weitere Kommandos wie
z.B. \passthrough{\lstinline!M150!} mit welchem spezielle Ausgänge für
LEDs gesteuert werden können. Dieses Feature bietet die verwendete
Marlin-FW\cite{marlinfw}, als auch die verwendete Steuerung an.
Sollte die Steuerung solch ein optionales Kommando nicht untersützen, so
werden diese ignoriert und somit können auch preisgünstige Steuerungen
verwendet werden.

Die Kommunikation zwischen Steuerung und eingebetteten System geschieht
durch eine \gls{usb} Verbinden. Die Steuerung meldet sich als virtuelle
Serielle Schnittstelle im System an und kann über diese mit der Software
kommunizieren. Auch werden so keine speziellen Treiber benötigt, da auf
nahezu jedem System ein Treiber (USB CDC) für die gängisten \gls{usb} zu
Seriell Wandler bereits instlliert ist. Die Software erkennt anhand der
zur Verfügung stehenden USB Geräte, sowie deren Vendor und Product-ID
Informationen die Steuerung automatisch und verwendet diese nach dem
Start automatisch. Hierzu wurde zuvor eine Liste mit verschiedenen
getesteten Steuerungen sowie deren USB Vendor und Product-ID angelegt.

\begin{longtable}[]{@{}llll@{}}
\caption{Hinterlegte G-Code Steuerungen}\tabularnewline
\toprule
Product & Vendor-ID & Product-ID & Board-Type\tabularnewline
\midrule
\endfirsthead
\toprule
Product & Vendor-ID & Product-ID & Board-Type\tabularnewline
\midrule
\endhead
Bigtreetech SKR 1.4 Turbo & 1d50 & 6029 &
Stepper-Controller\tabularnewline
Bigtreetech SKR 1.4 & 1d50 & 6029 & Stepper-Controller\tabularnewline
Bigtreetech SKR 1.3 & 1d50 & 6029 & Stepper-Controller\tabularnewline
\bottomrule
\end{longtable}

Damit die Software mit der Steuerung kommunizieren kann, wurde eine
G-Code Sender Klasse implementiert, welche die gleichen Funtionen wie
die HAl-Basisklasse bereitstellen. Nach Aufruf einer Funktion zum
Ansteuern der Motoren, wird aus den übergeben Parametern das passende
G-Code Kommando in Form einer Zeichenkette zusammengesetzt und auf die
Serielle Schnittstelle geschrieben.

\begin{lstlisting}[language={C++}]
//GCodeSender.cpp
bool GCodeSender::setServo(const int _index,const int _pos) {
    return write_gcode("M280 P" + std::to_string(_index) + " S" + std::to_string(_pos));     //MOVE SERVO
}

bool GCodeSender::write_gcode(std::string _gcode_line, bool _ack_check) {
    //...
    //...
    //FLUSH INPUT BUFFER
    port->flushReceiver();
    //APPEND NEW LINE CHARAKTER IF NEEDED
    if (_gcode_line.rfind('\n') == std::string::npos)
    {
        _gcode_line += '\n';
    }
    //WRITE COMMAND TO SERIAL LINE
    port->writeString(_gcode_line.c_str());
    //WAIT FOR ACK
    return wait_for_ack();
}

bool GCodeSender::wait_for_ack() {  
    int wait_counter = 0;
    //...
    //...
    while (true) {
        //READ SERIAL REPONSE
        const std::string resp = read_string_from_serial();
        //...
        //...
        //PROCESS
        if (resp.rfind("ok") != std::string::npos)
        {
            break;
        }else if(resp.rfind("echo:Unknown") != std::string::npos) {
            break;
        }else if(resp.rfind("Error:") != std::string::npos) {
            break;          
        }else if (resp.rfind("echo:busy: processing") != std::string::npos) {
            wait_counter = 0;
            LOG_F("wait_for_ack: busy_processing");
        }else {
            //READ ERROR COUNTER AND HANDLING
            wait_counter++;
            if (wait_counter > 3)
            {
                break;
            }
        }   
    }
    //...
    //...
    return true;
}
\end{lstlisting}

Die Steuerung verarbeitet diese und bestätigt die Ausführung mit einer
Acknowledgement-Antwort. Hierbei gibt es verschiedenen Typen. Der
einfachste Fall ist ein \passthrough{\lstinline!ok!}, welches ein
erfolgreiche Abarbeitung des Kommandos signalisiert. Ein weitere Fall
ist die Busy-Antwort \passthrough{\lstinline!echo:busy!}. Diese
Signalisiert, dass das Kommando noch in der Bearbeitung ist und wird im
falle des autonomen Schachtisch bei langen und langsamen Bewegungden der
Mechanik ausgegeben. Das System wartet diese Antworten ab, bis eine
finale \passthrough{\lstinline!ok!}-Antwort zurückgegeben wird, erst
dann wird das nächste Kommando abgearbeitet.

\hypertarget{hal-i2c-seriell-umsetzer}{%
\subsubsection{HAL: I2C Seriell
Umsetzer}\label{hal-i2c-seriell-umsetzer}}

Druch wegfall der zuvor eingesetzten Elektronik und der Austausch durch
due SKR 1.4 Turbo Steuerung, ist jedoch ein Anschluss des PN532
\gls{nfc} Moduls nicht mehr möglich. Da dieses mittels \gls{i2c}
Interface direkt mit dem eingebetteten Systems verbunden war. Diese
Möglichkeit besteht weiterhin, jedoch wurde auch hier auf eine \gls{usb}
Schnittstelle gewechselt. So ist es möglich das System auch an einem
anderen Host-System zu betreiben, wie z.B. an einem handelsüblichen
Computer. Dazu wurde ein Schnittstellenwandler hinzugefügt welcher die
\gls{i2c} Schnittstelle zu einer \gls{usb} Seriell wandelt. Hierzu wurde
ein Atmega328p Mikronkontroller eingesetzt, da dieser weit verbreitet
und preisgünstig zu beschaffen ist. Die Firmware des Mikrokontrollers
stellt ein einfaches Komanndobasierte Interface bereit. Die
Kommunikation ist mit der Kommunikation und der Implementierung des
G-Code Senders vergleichbar und teilen sich die gleichen Funktionen zur
Kommunikation mit der Seriellen Schnittstelle.

\begin{lstlisting}[language={C++}]
//userboardcontroller.cpp Atmega328p Firmware
//simplyfied version
char scan_nfc_tag(){
    //...
    if (nfc.tagPresent())
    {
        //READ TAG CONTENT
        NfcTag tag = nfc.read();
        //READ NDEF PAYLOAD
        NdefMessage msg = tag.getNdefMessage();
        if(msg.getRecordCount() > 0){
            //READ FIRST RECORD
            NdefRecord record = msg.getRecord(0);
            const int payloadLength = record.getPayloadLength();
            byte payload[payloadLength];
            //...
            record.getPayload(payload);
            //...
            //...
            //RETURN FIGURE ID
            if(payloadLength == 6){
                return payload[3];
            }
        }
    return 0; //VALID TAGS FROM 1-127
}
\end{lstlisting}

Hier wird nur ein Befehl zum auslesen des \gls{nfc} Tags benötigt. Das
Host-System sendet die Zeichenkette
\passthrough{\lstinline!\_readnfc\_!} zum Mikrokontroller und dieser
versucht über das PN532 Modul ein \gls{nfc} Tag zu lesen. Wenn dieses
erkannt wird und einen passenden Payload enthält, anwortet dieser mit
dem String \passthrough{\lstinline!\_readnfc\_res\_FIGURE-ID\_ok\_!}
oder wenn kein Tag gefunden wurde mit
\passthrough{\lstinline!\_readnfc\_red\_\_empty\_!}. Auch hier wird wie
bei der G-Code Sender Implementierung auf Fehler bei der Kommunikation
bzw einem Abbruch durch einen Timeout reagiert. Das System initialisiert
die Serielle Schnittstelle neu und resettet das System durch setzten des
DTR GPIO am USB-Seriell Wandler ICs (falls vorhanden).

\begin{lstlisting}[language={C++}]
//UserBoardController.cpp HOST-SYSTEM
//simplyfied version
ChessPiece::FIGURE UserBoardController::read_chess_piece_nfc(){

    ChessPiece::FIGURE fig;
    fig.type = ChessPiece::TYPE::TYPE_INVALID;
    //...
    //READ SERIAL RESULT
    const std::string readres = send_command_blocking(UBC_COMMAND_READNFC);
    //...
    //SPLIT STRING _
    const std::vector<std::string> re = split(readres,UBC_CMD_SEPERATOR);
    //READ SECTIONS
    //...
    //...
    const std::string figure = re.at(3);
    const std::string errorcode = re.at(4);
    //CHECK READ RESULT
    if(errorcode == "ok"){
        if(figure.empty()){
            break;
        }
        //...
        //...
        //DETERM FINAL READ FIGURE
        const char figure_charakter = figure.at(0);
        fig = ChessPiece::getFigureByCharakter(figure_charakter);
    }
    //...
    return fig;
}
\end{lstlisting}

Das System erkennt den anschluss der Hardware beim Start auf die gleiche
Art und Weise wie der G-Code Sender. Hierbei wurden einige verschiedene
Mikrokontroller System im System hinterlegt, welchen die Firmware
geteset wurde.

\begin{longtable}[]{@{}llll@{}}
\caption{Hinterlegte Mikrokontroller}\tabularnewline
\toprule
Product & Vendor-ID & Product-ID & Board-Type\tabularnewline
\midrule
\endfirsthead
\toprule
Product & Vendor-ID & Product-ID & Board-Type\tabularnewline
\midrule
\endhead
Arduino Due {[}Programming Port{]} & 2341 & 003d &
User-Move-Detector\tabularnewline
Arduino Due {[}Native SAMX3 Port{]} & 2341 & 003e &
User-Move-Detector\tabularnewline
CH340 & 1a86 & 7523 & User-Move-Detector\tabularnewline
HL-340 & 1a86 & 7523 & User-Move-Detector\tabularnewline
STM32F411 & 0483 & 5740 & User-Move-Detector\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{fazit-zum-finalen-prototypen}{%
\subsection{Fazit zum finalen
Prototypen}\label{fazit-zum-finalen-prototypen}}

\begin{itemize}
\tightlist
\item
  modularer hardware aufbau
\item
  einfach/gut verfügbare materialien verwendet
\item
  geänderte Mechnik resultiert in nahezu Spielfreier Mechanik (+- 1mm),
  welches für diesen Zweck mehr als ausreicht
\item
  6h dauertest bestanden
\end{itemize}

\begin{longtable}[]{@{}ll@{}}
\caption{Eigenschaften des finalen Prototypen}\tabularnewline
\toprule
& \gls{atc} -- autonomous Chessboard\tabularnewline
\midrule
\endfirsthead
\toprule
& \gls{atc} -- autonomous Chessboard\tabularnewline
\midrule
\endhead
Feldabmessungen (LxBxH) & 57x57mm\tabularnewline
Abmessungen (LxBxH) & 620x620x170mm\tabularnewline
Gewicht & 5.7kg\tabularnewline
Konnektivität & \gls{wlan}, \gls{usb}\tabularnewline
Automatisches Bewegen der Figuren & ja\tabularnewline
Erkennung Schachfigurstellung & ja\tabularnewline
Spiel Livestream & ja\tabularnewline
Cloud anbindung (online Spiele) & ja\tabularnewline
Parkposition für ausgeschiedene Figuren & ja\tabularnewline
Stand-Alone Funktionalität & ja\tabularnewline
Besonderheiten & User-Port für Erweiterungen\tabularnewline
\bottomrule
\end{longtable}

\begin{itemize}
\tightlist
\item
  alle anforderungen erfüllt
\item
  zulasten der geschwindigkeit insbesondere bei der erkennung des
  User-Move
\end{itemize}

\hypertarget{entwicklung-der-cloud-infrastruktur}{%
\section{Entwicklung der Cloud
Infrastruktur}\label{entwicklung-der-cloud-infrastruktur}}

Die erste Phase der Entwicklung des Systems bestand in der Entwicklung
der Cloud-Infrastruktur und der darauf laufenden Services. Hierbei
stellt die ``Cloud'', einen Server dar, welcher aus dem Internet über
eine feste IPv4 und IPv6-Adresse verfügt und frei konfiguriert werden
kann. Auf diesem System ist der Schach-Cloud Stack
\ref{ATC_Cloud_Architecture} installiert, welcher zum einen aus der
Schach-Software besteht, welche in einem Docker-Stack ausgefphrt wird
und zum anderen\ldots{}.

\begin{figure}
\centering
\includegraphics{images/ATC_Cloud_Architecture.png}
\caption{Gesamtübersicht der verwendeten Cloud-Infrastruktur
\label{ATC_Cloud_Architecture}}
\end{figure}

\hypertarget{api-design}{%
\subsection{API Design}\label{api-design}}

Das System soll so ausgelegt werden, dass es im späteren Zeitpunkt mit
verschiedenen Client-Devices mit diesem kommunizieren können. Dazu
zählen zum einen der autonome Schachtisch, aber z.B. auch einen
Web-Client, welcher die Funktionalität eines Schachtisch im Browser
abbilden kann. Hierzu muss das System eine einheitliche
\gls{rest}-Schnittstelle bereitstellen.

Eine RESTful API bezeichnet eine API welche HTTP-Requests verwendet um
auf Daten zugreifen zu können.

\begin{itemize}
\tightlist
\item
  grafik
\item
  5 requirements
\end{itemize}

Die RESTful API stellt verschiedene Ressourcen bereit, welche durch eine
URI \ref{ATC_URI_SCHEMES} eindeutig identifizierbar sind. Auf diese
können mittels verschiedenster HTTP Anfragemethoden (GET, POST, PUT,
DELETE) zugegriffen werden. Jeder dieser Methoden stellt einen anderen
Zugriff auf die Ressource dar und beeinflusst somit das Verhalten und
die Rückantwort dieser.

\begin{figure}
\centering
\includegraphics{images/ATC_URI_SCHEMES.png}
\caption{Cloud-Infrastruktur: Aufbau einer URI \label{ATC_URI_SCHEMES}}
\end{figure}

Eine URI besteht dabei aus mehreren Teilen. Das Schema gibt an wie die
nachfolgenden Teile interpretiert werden sollen. Dabei wird bei einer
RESTful Schnittstelle typischerweise das \gls{http} Protokoll, sowie
\gls{https} verwendet. Dabei steht \gls{https} für eine verschlüsselte
Verbindung. Desweiteren gibt es viele andere Schema, wie z.B \gls{ftp}
welches

Somit stellt die RESTful API eine Interoperabilität zwischen
verschiedenen Anwendungen und Systemen bereit, welche durch ein Netzwerk
miteinander verbunden sind. Dieser Ansatz ist somit geeignet um die
verschiedenen Client Systeme (Schachtisch, Webclient) eine Kommunikation
mit dem Server zu erlauben.

\hypertarget{service-architektur}{%
\subsection{Service Architektur}\label{service-architektur}}

\begin{itemize}
\tightlist
\item
  was ist ein Service
\item
  microservice ansatz
\item
  Kapselung der Schach spiel spzifischen funktionaliutäten
\item
  verwendung von NoSQL Datenbanken somit müssen tabellen nicht spzeill
  auf Schach spezifische felder ausgelegt sein
\item
  statelss Diese stellen alle wichtigen Funktionen zum Betrieb des
  autonomen Schachtischs zur verfügung.
\end{itemize}

\begin{figure}
\centering
\includegraphics{images/ATC_Service_Architecture.png}
\caption{Cloud-Infrastruktur: Aufbau der Service Architecture
\label{ATC_Service_Architecture}}
\end{figure}

\hypertarget{voruxfcberlegungen}{%
\subsubsection{Vorüberlegungen}\label{voruxfcberlegungen}}

\begin{itemize}
\tightlist
\item
  welche funktionalitäten müssen abgedeckt werden
\item
  client aktivitendiagram
\end{itemize}

\hypertarget{backend}{%
\subsubsection{Backend}\label{backend}}

\begin{figure}
\centering
\includegraphics{images/ATC_request_example.png}
\caption{Cloud-Infrastruktur: Backend Login-Requst und Response
\label{ATC_request_example}}
\end{figure}

\begin{itemize}
\tightlist
\item
  matchmaking schachlogik
\item
  zentraler zugriffspunkt auf das System und stellt diese abi bereit
\item
  stellt spielerprofile aus datenbanken bereit bereit
\item
  authentifizierung der clients und deren sessions
\item
  weiterleitung der von spielerinteraktionen an move validator
\item
  spielfelder werden als string übermittelt = hier fen representation;
  einfach zu parsen; standart
\end{itemize}

\hypertarget{movevalidator}{%
\subsubsection{MoveValidator}\label{movevalidator}}

Der MoveValidator-Service bildet im System die eigentliche Schachlogik
ab. Die Aufgabe ist es, die vom Benutzer eingegebenen Züge auf
Richtigkeit zu überprüfen und auf daraufhin neuen Spiel-Status
zurückzugeben. Dazu zählen unter anderem das neue Schachbrett und ob ein
Spieler gewonnen oder verloren hat.

Bevor ein Spiel begonnen wird, generiert der MoveValidator das initiale
Spielfeld und bestimmt den Spieler, welcher als erstes am Zug ist.

\begin{figure}
\centering
\includegraphics{images/ATC_movevalidator_execute_move.png}
\caption{MoveValidator: Beispiel Request zur Ausführung eines Zuges auf
einem gegebenen Schachbrett \label{ATC_movevalidator_execute_move}}
\end{figure}

Der Backend-Service fragt einen neues Spiel an oder übergibt einen
Schachzug inkl. des Spielbretts an den
Service.\ref{ATC_movevalidator_execute_move} Der Response wird dann vom
Backend in der Datenbank gespeichert und weiter an die Client-Devices
verteilt.

\begin{longtable}[]{@{}llll@{}}
\caption{MoveValidator-Service \gls{api} Overview}\tabularnewline
\toprule
AtomicChess Move-Validator Service \gls{api} & \gls{api}-Route & Method
& Form-Data\tabularnewline
\midrule
\endfirsthead
\toprule
AtomicChess Move-Validator Service \gls{api} & \gls{api}-Route & Method
& Form-Data\tabularnewline
\midrule
\endhead
Check Move & /rest/check\_move & POST & * fen * move *
player\tabularnewline
Execute Move & /rest/execute\_move & POST & fen * move\tabularnewline
Validate Board & /rest/validate\_board & POST & fen\tabularnewline
Init Board & /rest/init\_board & GET &\tabularnewline
\bottomrule
\end{longtable}

Allgemein geschieht die Kommunikation über vier \gls{api} Calls, welche
vom MoveValidator-Service angeboten werden. Als erstes wird vom Backend
der \passthrough{\lstinline!/rest/init\_board!} Request verwendet,
welcher ein neues Spielbrett in der \gls{fen} Notation zurückgibt,
welches zum Start der Partie verwendet wird. Allgemein arbeitet wurde
das komplette System so umgesetzt, dass dieses mit einem Spielfeld in
einer Zeichenketten/String arbeitet. Dies hat den Vorteil, dass die
Spielfeld-Notation leicht angepasst werden kann. Mit diesem Design ist
es möglich, auch andere Spielarten im System zu implementieren, nur hier
die initialen Spielfelder generiert werden und Züge der Spieler
validiert werden müssen.

Die \gls{fen} Notatin ist universal und kann jede Brettstellung
darstellen. Auch enhält diese nicht nur die Figurstellungen, sondern
auch weitere Informationen, wie die aktuelle Nummer des Zuges oder
welcher Spieler gerade an der Reihe ist. Diese werden dann in der
\gls{xfen} Notation angegeben, bei der zusätzlich zu der Brettstellung
auch noch die weiteren Informationen angehängt werden.

\begin{longtable}[]{@{}ll@{}}
\caption{Vergleich \gls{fen} - \gls{xfen}}\tabularnewline
\toprule
FEN-TYPE & FEN-String\tabularnewline
\midrule
\endfirsthead
\toprule
FEN-TYPE & FEN-String\tabularnewline
\midrule
\endhead
FEN & rnbqkbnr/pp1ppppp/8/2p5/4P3/5N2/PPPP1PPP/RNBQKB1R\tabularnewline
X-FEN & rnbqkbnr/pp1ppppp/8/2p5/4P3/5N2/PPPP1PPP/RNBQKB1R b KQkq - 1
2\tabularnewline
SCHEMA & Board Player-Color Rochade En-Passant Halfturn
Turn-Number\tabularnewline
\bottomrule
\end{longtable}

Alle gängigen Schachprogramme und Bibliotheken unterstützen das Laden
von Spielbrettern in der \gls{fen} bzw \gls{xfen} Schreibweise, ebenso
die für den MoveValidator Service verwendete Python-Chess Blibliothek
\cite{pythonchesslib}. Diese unterstützt zusätzlich die Generierung
der für den Benutzer möglichen Schachzügen, welche auf dem aktuellen
Brett möglich sind. Diese List wird vom System dazu verwendet um
sicherzustellen, das der Benutzer nur gültige Züge tätigen kann. Diese
Funktion lässt sich zusätzliche abschalten, falls das Spiel nicht nach
den allgemeinen Schachregeln ablaufen soll. Bei der Generierung der
möglichen Schachzügen, muss zwischen den Legal-Moves und den
Pseudo-Legal Schachzügen unterschieden werden. Die Legal-Moves
beinhalten nur die nach den Schachregeln möglichen Zügen, welche von
Figuren des Spielers ausgeführt werden können. Die Pseudo-Legal
Schachzüge, sind alle Schachzügen welche von den Figuren auf dem
aktuellen Schachbrett möglich, so sind z.B. auch alle anderen Figur-Züge
enthalten, wenn der König sich aktuell im Schach befindet.

Wenn ein Spieler an der Reihe ist, sein getätigter Zug mittels der
\passthrough{\lstinline!/rest/check\_move!} \gls{api} überprüft, ob
dieser gemäss der Legal-Moves durchführbar ist. Ist dies der Fall, wird
der Zug auf das Spielbrett angewendet, welches durch die
\passthrough{\lstinline!/rest/execute\_move!} \gls{api} geschieht. Diese
führ den Zug aus und ermittelt somit das neue Spielbrett und überprüft
zusätzlich, ob das Spiel gewonnen oder verloren wurde.

Hat der Benutzer jedoch einen ungültigen Zug ausgeführt, wird dieser vom
System storniert und der Client des Benutzers stellt den Zusand des
Spielbretts vor dem getätigten Zug wiederher. Danach hat der Benutzer
die Möglichkeit einen alternativen Zug auszuführen.

\hypertarget{entwicklung-webclient}{%
\subsubsection{Entwicklung Webclient}\label{entwicklung-webclient}}

\begin{figure}
\centering
\includegraphics{images/ATC_webclient.png}
\caption{Webclient: Spielansicht \label{ATC_webclient}}
\end{figure}

Der Webclient wurde primär dazu entwickelt um das System während der
Entwicklung zu testen. Dieser simuliert einen autonomen Schachtisch und
verwendet dabei die gleichen \gls{http} Requests. Dieser wurde dabei
komplett in \gls{js} umgesetzt im Zusammenspiel mit \gls{html} und
\gls{css} und ist somit komplett im Browser lauffähig.

Ausgeliefert werden die statischen Dateien zur Einfachheit durch den
Backend-Service, es wurde kein gesonderter Frontend-Service angelegt.
Durch die Implementierung des Webclienten in \gls{js}, ist dieser sogar
lokal über einen Browser ausführbar, ohne dass die benötigten Dateien
über einen Webserver ausgeliefert werden müssen.

Zusätzlich zu dem verwendeten Vanilla-\gls{js} wurde jQuery als
zusätzliche \gls{js} Bibliothek verwendet, welches eine Manipulation der
\gls{html} Elemente stark vereinfacht. Diese bietet insbesondere einfach
zu nutzende HTTP-Request Funktionen bzw. \gls{ajax} an, welche für die
Kommunikation mit dem Backen-Service verwendet werden. Diese werden im
Hintergrund eingesetzt, sodass der Webclient automatisch den neuen
Spielzustand dem Benutzer anzeigt. Dies geschieht mittels
\passthrough{\lstinline!polling!}, bei dem der Webbrowser in zyklischen
Abständen die aktuellen Spiel-Informationen vom Backen-Service abfragt.
Diese Methode wurde verwendet, um eine maximale Kompatibilität mit
verschiedensten ggf älteren Web-Browsern sicherzustellen. Eine moderne
alternative ist die Verwendung von Web-Sockets, bei welcher der
Web-Browser eine direkte TCP-Verbindung zum Webserver (in diesem Fall
der Backend-Service) aufnhemen kann und so eine direkte Kommunikation
stattfinden kann ohne Verwendung der
\passthrough{\lstinline!polling!}-Methode.

Der Hauptanwendungsfall des Webclienten wärend der Entwicklung, ist es
weitere Spieler zu simulieren und so ein Spiel mit nur einem autonomen
Schachtisch test zu können. Durch den Webclient ist zusätzliche möglich,
gezielt Spiele und Spielzüge zu simulieren. Hierzu gehöhren vorallem
Sonderzüge wie die Rochade oder der En-Passant Zug. Auch können durch
den Webclient ungültige Züge gezogen werden, welche z.B. durch eine
Schach-AI nicht getätigt werden.

Während der Implementierung wurde der Webclient weiter ausgebaut und es
wurde weitere Features ergänzt. Dazu zählt zum einen eine Übersicht über
vergangene und aktuell laufende Spiele. In dieser können Spiele Zug um
Zug nachvollzogen werden und weitere Information über den Spielstatus
angezeigt werden.\ref{ATC_statistics} Auch ist es möglich aktuell
laufende Spiele in Echtzeit anzeigen zu lassen, somit wurde eine
Livestream-Funktionaliät implementiert.

\begin{figure}
\centering
\includegraphics{images/ATC_statistics.png}
\caption{Webclient: Statistiken \label{}}
\end{figure}

\hypertarget{autoplayer}{%
\subsubsection{AutoPlayer}\label{autoplayer}}

Der AutoPlayer-Service stellt den Computerspieler bereit. Jede
Service-Instanz stellt einen virtuellen Spieler bereit, welcher die
gleiche Schnittstellen wie der Webclient oder der autonme Schachtisch
verwendet. Die einzige Änderung an den verwendeten \gls{rest}-Calls ist
der Login-Requst. Hier wird das \passthrough{\lstinline!playertype!}
Flag gesetzt welches den Spieler als Computerspieler gegenüber des
Systems authentifiziert. Somit wird dieser wärend des
Matchmaking-Prozesses erst für ein Match ausgewählt, wenn kein anderer
Spieler mehr zur Verfügung steht, welcher vom Typ Webclient oder
autonomer Schachtisch ist. Somit ist gewährleistet, dass immer zuerst
die Menschlichen-Spieler ein Spiel beginnen.

Eine weitere Modifikation ist die verwendung einer Schach-AI, da dieser
Service als Computerspieler agieren soll. Hierzu kam die Open-Source
Chess Engine Stockfish\cite{stockfish} in der Version 11 zum
Einsatz. Die Stockfish-Engine bietet noch weitere Features, als nur die
nöchst besten Züge zu einem gegebenen Schachbrett zu ermitteln. Sie kann
auch genutzt werden um Züge zu klassifizieren und bietet
Analysemöglichkeiten für Spielstellungen.

Die AutoPlayer-Instanz kommuniziert über das \gls{uci}
Protokoll\cite{uciprotocol} mit der Executable der Stockfish-Engine.
Dieses Protokoll wird in der Regel von Schach-Engines um mit einer
\gls{gui} zu Kommunizieren und die Kommunikation erfolgt über
Klartextbefehle. Um das aktuelle Spielbrett in der Engine zu setzten
wird dieses in der \gls{fen} Notation mit dem Prefix
\passthrough{\lstinline!position fen!} als Klartext an die Engine
übergben.

Im Kontext des AutoPlayer-Service wird der Engine nur das aktuelle
Spielbrett übermittelt und der nächst beste Zug ausgelsen. Dies wird
Ausgeführt, wenn der AutoPlayer am Zug ist. Nachdem die Engine einen
passenden Zug gefunden hat, wird das Ergebnis über den
\passthrough{\lstinline!make\_move!} \gls{rest}-API Call übermittelt.

Wenn das Match beendet wird, beendet sich auch die Service-Instanz.
Diese wird jedoch wieder gestartet wenn die Anzahl der zur Verfügung
stehenden Computerspieler unter einen definierten Wert fallen. Somit ist
dafür gesorgt, dass das System nicht mit ungenutzen AutoPlayer-Instanzen
gebremst wird. Diese Anzahl \ref{ai_player_count} ist in der
Backend-Configuration frei wählbar und kann je nach zu erwartenen
Aufkommen angepasst werden.

Allgemein skaliert das System durch diese Art der Ressourcenverwaltung
auch auf kleinen Systemen sehr flexibel. Durch die Art der
Implementierung, dass sich der AutoPlayer-Service wie ein normaler
Spieler verhält, sind auch andere Arten des Computerspieler möglich. So
ist es zum Beispiel möglich, die Spielstärke je Spieler anzupassen oder
einen Computerspieler zu erstellen, welcher nur zufällige Züge zieht.

Ein weiterer Anwendungsfall für den AutoPlayer-Service, ist das Testen
des weiteren Systems insbesondere des Backend-Service. Durch das
Matching von zwei AutoPlayer-Instanzen, können automatisierte test
Schachpartien ausgeführt werden um die Funktionsfähigkeit des restlichen
Systems zu testen. Diese Feature wurde insbesondere bei der Entwicklung
des Webclienten und der Steuerungssoftware für den autonomen Schachtisch
verwendet.

\hypertarget{authetifizierung}{%
\subsubsection{Authetifizierung}\label{authetifizierung}}

\begin{itemize}
\tightlist
\item
  authetifizierung
\item
  https only
\item
  Zertifikate auf Clientseite geniert jedoch nicht Abgefragt
\end{itemize}

\hypertarget{embedded-system-software}{%
\section{Embedded System Software}\label{embedded-system-software}}

\begin{itemize}
\tightlist
\item
  Hauptsoftware zur Steuerung der Elektrik/Mechanik
\item
  Kommunikation mit dem Cloud-Server
\end{itemize}

\hypertarget{ablaufdiagramm}{%
\subsection{Ablaufdiagramm}\label{ablaufdiagramm}}

\begin{itemize}
\tightlist
\item
  dummer/thin Client
\item
  Synchronisierung von gegeben Schachfeld mit dem lokalen Schachfeld
\item
  getätigte züfe werden direkt an den schachserver geschickt und dieser
  generiert darauf hin das neue schachbrett welches von beiden Partner
  sync
\end{itemize}

\begin{figure}
\centering
\includegraphics{images/ATC_gameclient_statemachiene.png}
\caption{Embedded System Software: Ablaufdiagramm
\label{ATC_gameclient_statemachiene}}
\end{figure}

\hypertarget{figur-bewegungspfadberechnung}{%
\subsection{Figur
Bewegungspfadberechnung}\label{figur-bewegungspfadberechnung}}

\begin{itemize}
\tightlist
\item
  Algorithmus zur Umsetzung eines Schachzugs
\item
  Auftrennung in current und target Board
\item
  vier Schritte (enfernen, bewegen, hinzufügen, bewegen) \#\# Schachfeld
  Scan Algorithmus zur Erkennung von Schachzügen
\end{itemize}

\begin{figure}
\centering
\includegraphics{images/ATC_ChessMoveAlgorithm.png}
\caption{Embedded System Software: Schachfeld Scan Algorithmus Ablauf
\label{ATC_ChessMoveAlgorithm}}
\end{figure}

\begin{itemize}
\tightlist
\item
  Benutzer bestätigt dass er Schachzug gemacht hat
\item
  Ermittlung des getätigten Schachzug
\item
  Scan der Schachfeld-Veränderungen, durch Vergleich des vorherigen
  Schachfelds und der möglichen Züge
\end{itemize}

\hypertarget{userinterface}{%
\subsection{Userinterface}\label{userinterface}}

Das Userinterface ist mit das zentrale Element mit welchem der Benutzer
interagiert. Hierbei soll dieses nur die nötigsten Funktionen
bereitstellen, welche zur Bedienung des Schachtisches nötig sind.

\begin{itemize}
\tightlist
\item
  grosse schaltflächen
\item
  kleine Menutiefe max. ein untermenü
\end{itemize}

\begin{figure}
\centering
\includegraphics{images/ATC_Gui.png}
\caption{Embedded System Software: User-Interface Mockup
\label{ATC_Gui}}
\end{figure}

\begin{itemize}
\tightlist
\item
  QT Quick UI, als Package in Buildroot integriert
\item
  IPC Bibliothek zur Kommunikation mit der controller-Software Instanz
\item
  JSON basiert =\textgreater{} einfaches Debugging
\item
  Steuerung über andere Endgeräte möglich z.B Handy-App welche im selben
  Netzwerk befindet.
\end{itemize}

\hypertarget{fazit}{%
\section{Fazit}\label{fazit}}

Zusammenfassend lässt sich festellen, dass das Ziel der Arbeit erreicht
wurde. Es wurde ein Prototyp eines autonomen Schachtischs entwickelt.

\begin{itemize}
\item
  mit am weitesten forgeschrittener open-source autonomes Schachtisch
  Projekt
\item
  vom versierten Benutzer selbstädig aufbaubar
\item
  leichte bedienung
\item
  lässt spiel für erweiterungen
\item
\end{itemize}

\hypertarget{ausblick}{%
\subsection{Ausblick}\label{ausblick}}

\begin{itemize}
\tightlist
\item
  Einbindung in existeirende Schach-Clouds z.B. https://lichess.org/
\item
  user-port für Erweiterungen (z.B. DGT Schachur)
\end{itemize}
