<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Strict//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>/home/miles/git/BitChess/BitChess/.README.md.html</title>


<style type="text/css">
body {
	color: #333;
	font: 13px/1.4 "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif;
	padding: 0;
	margin: 0;
}

a {
	background: transparent;
	color: #4183c4;
	text-decoration: none;
}

a:active,
a:hover {
	outline: 0 none;
	text-decoration: underline;
}

abbr[title] {
	border-bottom: 1px dotted;
}

b,
strong {
	font-weight: bold;
}

dfn {
	font-style: italic;
}
h1 {
	font-size: 2em;
	margin: 0.67em 0;
}
mark {
	background: #ff0;
	color: #000;
}
small {
	font-size: 80%;
}
sub, sup {
	font-size: 75%;
	line-height: 0;
	position: relative;
	vertical-align: baseline;
}
sup {
	top: -0.5em;
}
sub {
	bottom: -0.25em;
}
img {
	border: 0 none;
}
svg:not(:root) {
	overflow: hidden;
}
figure {
	margin: 1em 40px;
}
hr {
	box-sizing: content-box;
	height: 0;
}

code,
kbd,
pre,
samp {
	font-family: monospace,monospace;
	font-size: 1em;
}

pre {
	overflow: auto;
	font: 12px Consolas,"Liberation Mono",Menlo,Courier,monospace;
	margin-bottom: 0;
	margin-top: 0;
}

.markdown-body {
	padding: 30px;
	font-size: 16px;
	line-height: 1.6;
	word-wrap: break-word;
}

.markdown-body>*:first-child {
	margin-top: 0 !important;
}

.markdown-body>*:last-child {
	margin-bottom: 0 !important;
}

.markdown-body .absent {
	color: #c00;
}

.markdown-body .anchor {
	position: absolute;
	top: 0;
	bottom: 0;
	left: 0;
	display: block;
	padding-right: 6px;
	padding-left: 30px;
	margin-left: -30px;
}

.markdown-body .anchor:focus {
	outline: none;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
	position: relative;
	margin-top: 1em;
	margin-bottom: 16px;
	font-weight: bold;
	line-height: 1.4;
}

.markdown-body h1 .octicon-link,
.markdown-body h2 .octicon-link,
.markdown-body h3 .octicon-link,
.markdown-body h4 .octicon-link,
.markdown-body h5 .octicon-link,
.markdown-body h6 .octicon-link {
	display: none;
	color: #000;
	vertical-align: middle;
}

.markdown-body h1:hover .anchor,
.markdown-body h2:hover .anchor,
.markdown-body h3:hover .anchor,
.markdown-body h4:hover .anchor,
.markdown-body h5:hover .anchor,
.markdown-body h6:hover .anchor {
	padding-left: 8px;
	margin-left: -30px;
	line-height: 1;
	text-decoration: none;
}

.markdown-body h1:hover .anchor .octicon-link,
.markdown-body h2:hover .anchor .octicon-link,
.markdown-body h3:hover .anchor .octicon-link,
.markdown-body h4:hover .anchor .octicon-link,
.markdown-body h5:hover .anchor .octicon-link,
.markdown-body h6:hover .anchor .octicon-link {
	display: inline-block;
}

.markdown-body h1 tt,
.markdown-body h1 code,
.markdown-body h2 tt,
.markdown-body h2 code,
.markdown-body h3 tt,
.markdown-body h3 code,
.markdown-body h4 tt,
.markdown-body h4 code,
.markdown-body h5 tt,
.markdown-body h5 code,
.markdown-body h6 tt,
.markdown-body h6 code {
	font-size: inherit;
}

.markdown-body h1 {
	padding-bottom: 0.3em;
	font-size: 2.25em;
	line-height: 1.2;
	border-bottom: 1px solid #eee;
}

.markdown-body h2 {
	padding-bottom: 0.3em;
	font-size: 1.75em;
	line-height: 1.225;
	border-bottom: 1px solid #eee;
}

.markdown-body h3 {
	font-size: 1.5em;
	line-height: 1.43;
}

.markdown-body h4 {
	font-size: 1.25em;
}

.markdown-body h5 {
	font-size: 1em;
}

.markdown-body h6 {
	font-size: 1em;
	color: #777;
}

.markdown-body p,.markdown-body blockquote,
.markdown-body ul,.markdown-body ol,
.markdown-body dl,.markdown-body table,
.markdown-body pre {
	margin-top: 0;
	margin-bottom: 16px;
}

.markdown-body hr {
	height: 4px;
	padding: 0;
	margin: 16px 0;
	background-color: #e7e7e7;
	border: 0 none;
}

.markdown-body ul,
.markdown-body ol {
	padding-left: 2em;
}

.markdown-body ul.no-list,
.markdown-body ol.no-list {
	padding: 0;
	list-style-type: none;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
	margin-top: 0;
	margin-bottom: 0;
}

.markdown-body li>p {
	margin-top: 16px;
}

.markdown-body dl {
	padding: 0;
}

.markdown-body dl dt {
	padding: 0;
	margin-top: 16px;
	font-size: 1em;
	font-style: italic;
	font-weight: bold;
}

.markdown-body dl dd {
	padding: 0 16px;
	margin-bottom: 16px;
}

.markdown-body blockquote {
	padding: 0 15px;
	color: #777;
	border-left: 4px solid #ddd;
}

.markdown-body blockquote>:first-child {
	margin-top: 0;
}

.markdown-body blockquote>:last-child {
	margin-bottom: 0;
}

.markdown-body table {
	display: block;
	width: 100%;
	overflow: auto;
	word-break: normal;
	word-break: keep-all;
}

.markdown-body table th {
	font-weight: bold;
}

.markdown-body table th,
.markdown-body table td {
	padding: 6px 13px;
	border: 1px solid #ddd;
}

.markdown-body table tr {
	background-color: #fff;
	border-top: 1px solid #ccc;
}

.markdown-body table tr:nth-child(2n) {
	background-color: #f8f8f8;
}

.markdown-body img {
	max-width: 100%;
	-moz-box-sizing: border-box;
	box-sizing: border-box;
}

.markdown-body span.frame {
	display: block;
	overflow: hidden;
}

.markdown-body span.frame>span {
	display: block;
	float: left;
	width: auto;
	padding: 7px;
	margin: 13px 0 0;
	overflow: hidden;
	border: 1px solid #ddd;
}

.markdown-body span.frame span img {
	display: block;
	float: left;
}

.markdown-body span.frame span span {
	display: block;
	padding: 5px 0 0;
	clear: both;
	color: #333;
}

.markdown-body span.align-center {
	display: block;
	overflow: hidden;
	clear: both;
}

.markdown-body span.align-center>span {
	display: block;
	margin: 13px auto 0;
	overflow: hidden;
	text-align: center;
}

.markdown-body span.align-center span img {
	margin: 0 auto;
	text-align: center;
}

.markdown-body span.align-right {
	display: block;
	overflow: hidden;
	clear: both;
}

.markdown-body span.align-right>span {
	display: block;
	margin: 13px 0 0;
	overflow: hidden;
	text-align: right;
}

.markdown-body span.align-right span img {
	margin: 0;
	text-align: right;
}

.markdown-body span.float-left {
	display: block;
	float: left;
	margin-right: 13px;
	overflow: hidden;
}

.markdown-body span.float-left span {
	margin: 13px 0 0;
}

.markdown-body span.float-right {
	display: block;
	float: right;
	margin-left: 13px;
	overflow: hidden;
}

.markdown-body span.float-right>span {
	display: block;
	margin: 13px auto 0;
	overflow: hidden;
	text-align: right;
}

.markdown-body code,.markdown-body tt {
	padding: 0;
	padding-top: 0.2em;
	padding-bottom: 0.2em;
	margin: 0;
	font-size: 85%;
	background-color: rgba(0,0,0,0.04);
	border-radius: 3px;
}

.markdown-body code:before,
.markdown-body code:after,
.markdown-body tt:before,
.markdown-body tt:after {
	letter-spacing: -0.2em;
	content: "\00a0";
}

.markdown-body code br,
.markdown-body tt br {
	display: none;
}

.markdown-body del code {
	text-decoration: inherit;
}

.markdown-body pre>code {
	padding: 0;
	margin: 0;
	font-size: 100%;
	word-break: normal;
	white-space: pre;
	background: transparent;
	border: 0;
}

.markdown-body .highlight {
	margin-bottom: 16px;
}

.markdown-body .highlight pre,
.markdown-body pre {
	padding: 16px;
	overflow: auto;
	font-size: 85%;
	line-height: 1.45;
	background-color: #f7f7f7;
	border-radius: 3px;
}

.markdown-body .highlight pre {
	margin-bottom: 0;
	word-break: normal;
}

.markdown-body pre {
	word-wrap: normal;
}

.markdown-body pre code,
.markdown-body pre tt {
	display: inline;
	max-width: initial;
	padding: 0;
	margin: 0;
	overflow: initial;
	line-height: inherit;
	word-wrap: normal;
	background-color: transparent;
	border: 0;
}

.markdown-body pre code:before,
.markdown-body pre code:after,
.markdown-body pre tt:before,
.markdown-body pre tt:after {
	content: normal;
}

.highlight .pl-coc,
.highlight .pl-entl,
.highlight .pl-entm,
.highlight .pl-eoa,
.highlight .pl-mai .pl-sf,
.highlight .pl-mm,
.highlight .pl-pdv,
.highlight .pl-sc,
.highlight .pl-som,
.highlight .pl-sr,
.highlight .pl-v,
.highlight .pl-vpf {
	color: #0086b3;
}
.highlight .pl-eoac,
.highlight .pl-mdht,
.highlight .pl-mi1,
.highlight .pl-mri,
.highlight .pl-va,
.highlight .pl-vpu {
	color: #008080;
}
.highlight .pl-c,
.highlight .pl-pdc {
	color: #b4b7b4;
	font-style: italic;
}
.highlight .pl-k,
.highlight .pl-ko,
.highlight .pl-kolp,
.highlight .pl-mc,
.highlight .pl-mr,
.highlight .pl-ms,
.highlight .pl-s,
.highlight .pl-sok,
.highlight .pl-st {
	color: #6e5494;
}
.highlight .pl-ef,
.highlight .pl-enf,
.highlight .pl-enm,
.highlight .pl-entc,
.highlight .pl-eoi,
.highlight .pl-sf,
.highlight .pl-smc {
	color: #d12089;
}
.highlight .pl-ens,
.highlight .pl-eoai,
.highlight .pl-kos,
.highlight .pl-mh .pl-pdh,
.highlight .pl-mp,
.highlight .pl-pde,
.highlight .pl-stp {
	color: #458;
}
.highlight .pl-enti {
	color: #d12089;
	font-weight: bold;
}
.highlight .pl-cce,
.highlight .pl-enc,
.highlight .pl-kou,
.highlight .pl-mq {
	color: #f93;
}
.highlight .pl-mp1 .pl-sf {
	color: #458;
	font-weight: bold;
}
.highlight .pl-cos,
.highlight .pl-ent,
.highlight .pl-md,
.highlight .pl-mdhf,
.highlight .pl-ml,
.highlight .pl-pdc1,
.highlight .pl-pds,
.highlight .pl-s1,
.highlight .pl-scp,
.highlight .pl-sol {
	color: #df5000;
}
.highlight .pl-c1,
.highlight .pl-cn,
.highlight .pl-pse,
.highlight .pl-pse .pl-s2,
.highlight .pl-vi {
	color: #a31515;
}
.highlight .pl-mb,
.highlight .pl-pdb {
	color: #df5000;
	font-weight: bold;
}
.highlight .pl-mi,
.highlight .pl-pdi {
	color: #6e5494;
	font-style: italic;
}
.highlight .pl-ms1 {
	background-color: #f5f5f5;
}
.highlight .pl-mdh,
.highlight .pl-mdi {
	font-weight: bold;
}
.highlight .pl-mdr {
	color: #0086b3;
	font-weight: bold;
}
.highlight .pl-s2 {
	color: #333;
}
.highlight .pl-ii {
	background-color: #df5000;
	color: #fff;
}
.highlight .pl-ib {
	background-color: #f93;
}
.highlight .pl-id {
	background-color: #a31515;
	color: #fff;
}
.highlight .pl-iu {
	background-color: #b4b7b4;
}
.highlight .pl-mo {
	color: #969896;
}

</style>


<script type="text/javascript">

function getDocumentScrollTop() 
{
   var res = document.body.scrollTop || document.documentElement.scrollTop || window.pageYOffset || 0;
   // alert(res);
   return res;
}

function setDocumentScrollTop(ypos) 
{
	window.scrollTo(0, ypos);
}

</script>


</head>
<body class="markdown-body">
<h1> <a id="user-content-bitchess" class="anchor" href="#bitchess" aria-hidden="true"><span class="octicon octicon-link"></span></a>BitChess</h1> 
<h2> <a id="user-content-overview" class="anchor" href="#overview" aria-hidden="true"><span class="octicon octicon-link"></span></a>Overview</h2> 
<p>BitChess is a simple C++ chess engine. It is intended to be used with <a href="http://www.gnu.org/software/xboard/engine-intf.html">Xboard/Winboard protocol</a> compatible chess GUIs (with potential UCI support in the future). This doc outlines the implementation and architecture behind the project.</p> 
<h3> <a id="user-content-goals" class="anchor" href="#goals" aria-hidden="true"><span class="octicon octicon-link"></span></a>Goals</h3> 
<p>[ordered by importance]</p> 
<h4> <a id="user-content-goals-of-first-version" class="anchor" href="#goals-of-first-version" aria-hidden="true"><span class="octicon octicon-link"></span></a>Goals of first version</h4> 
<ul> 
 <li>Generation of all legal moves in a particular position</li> 
 <li>The use of a simpler on-the-fly algorithm for generating moves for sliding pieces (rooks/bishops/queens) based on the <a href="https://chessprogramming.wikispaces.com/Subtracting+a+rook+from+a+blocking+piece">o^(o-2r</a> trick (with <a href="https://chessprogramming.wikispaces.com/Hyperbola+Quintessence">diagonal</a> support)</li> 
 <li>Selection of a legal move based on a basic evaluation of a position from amount of material</li> 
 <li><p>Full compatibility for use with a XBoard/Winboard GUI (could potentially reuse source from another opensource chess engine)</p></li> 
 <li><p>Correctness over speed: whilst reasonably optimal data structures shall be used (e.g. hash maps and bitboards) the focus shall be on producing a working engine than a speedy one. Simple calculations such as king and knight move generation will be optimised through the use of lookup tables.</p></li> 
 <li>Time management shall also not be implemented, as searches are effectively 1-ply (meaning only the engine's next move is considered, rather than calculating, e.g. 7 moves ahead)</li> 
</ul> 
<h4> <a id="user-content-future-goals" class="anchor" href="#future-goals" aria-hidden="true"><span class="octicon octicon-link"></span></a>Future goals</h4> 
<ul> 
 <li>Evaluation of a position</li> 
 <li>Search for optimal move based on evaluation</li> 
 <li>Time management</li> 
 <li>The use of <a href="https://chessprogramming.wikispaces.com/Magic+Bitboards">Magic</a> <a href="http://www.pradu.us/old/Nov27_2008/Buzz/research/magic/Bitboards.pdf">Bitboards</a> for rapid sliding piece move generation via table lookup</li> 
 <li>Optimisation of move generation (e.g. generate moves in an optimal order)</li> 
 <li>General optimisation</li> 
 <li>UCI compatibility</li> 
</ul> 
<h3> <a id="user-content-architecture" class="anchor" href="#architecture" aria-hidden="true"><span class="octicon octicon-link"></span></a>Architecture</h3> 
<p>The central controller is the <strong>Game</strong> class, which communicates with the user through an <strong>XBoard protocol class</strong> and external GUI. The <strong>Game</strong> class keeps track of moves played, and updates the current <strong>Position</strong> with moves received. The <strong>Position</strong> consists of a collection of <strong>Piece</strong> (s) which generate their own pseudo-legal <strong>Move</strong> (s). The <strong>Moves</strong> of each <strong>Piece</strong> on the side to move are combined in a single collection in the <strong>Position</strong> which lists available pseudo-legal moves. An <strong>Evaluator</strong> analyses the consequence of each move, assigning it a score. The <strong>Searcher</strong> searches through the evaluated positions to find the best next move to play, and the <strong>Game</strong> passes this to the interface.</p> 
<h2> <a id="user-content-requirements-of-each-class" class="anchor" href="#requirements-of-each-class" aria-hidden="true"><span class="octicon octicon-link"></span></a>Requirements of each class</h2> 
<h3> <a id="user-content-board-representation" class="anchor" href="#board-representation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Board representation</h3> 
<p>For ease of access and display, each position has an <a href="https://chessprogramming.wikispaces.com/8x8+Board">8x8 array</a> of pieces associated with it. Move generation and evaluation, are, however, represented by <a href="https://chessprogramming.wikispaces.com/Bitboards">bitboards</a>, a bitset of 64 bits each representing a square. Each piece type has an occupancy bitboard, e.g. the black rook occupancy might look like:<code> 1 . . . . . . 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</code> (which would be <code>100000010000...</code> in binary or <code>0x8100000000000000</code> in hex). Using a combination of these fundamental atomic bitboards, various shift operations (to simulate moving a piece), bit operations (e.g. bitwise <code>OR</code> to get the union of each bitset) and special bitmasks a variety of more complex bitboards can be calculated for evaluation and move generation. For example, bitwise <code>OR</code> of all the pieces generates an overall square occupancy bitboard, with <code>1</code> representing any piece:<code> 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1</code> The bitwise <code>NOT</code> operation gets the complement, which shows empty squares.</p> 
<h3> <a id="user-content-int-main" class="anchor" href="#int-main" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>int main()</code> </h3> 
<p>Initialises the XBoardInterface which controls the program.</p> 
<h3> <a id="user-content-xboardctrl" class="anchor" href="#xboardctrl" aria-hidden="true"><span class="octicon octicon-link"></span></a>XBoardCtrl</h3> 
<p>Is a singleton. Parses and processes XBoard commands from a given input/outputstream, controlling the <code>Game</code> class.</p> 
<ul> 
 <li>constructs the class, using given input and output streams for I/O.</li> 
 <li>Sends a list of features to enable/disable on <code>out</code> </li> 
 <li>Polls <code>stdin</code> for input and call relevant commands</li> 
</ul> 
<p>A detailed list of implementation of XBoard commands is below.</p> 
<h3> <a id="user-content-game" class="anchor" href="#game" aria-hidden="true"><span class="octicon octicon-link"></span></a>Game</h3> 
<p>Also a singleton. Controls the decision making process, guided by signals from an external source, e.g. <code>XBoardCtrl</code>. </p> 
<ul> 
 <li>A polling function can be set as a callback</li> 
 <li>Calls the polling function regularly</li> 
 <li>Requests next move from the <code>Searcher</code>, passing the <code>current_position</code>.</li> 
</ul> 
<h3> <a id="user-content-searcher" class="anchor" href="#searcher" aria-hidden="true"><span class="octicon octicon-link"></span></a>Searcher</h3> 
<p>Searches for the next best legal move to play.</p> 
<ul> 
 <li>Uses the <code>Evaluator</code> to evaluate the <code>current_position</code>. </li> 
 <li>Requests a list of legal moves from the <code>current_position</code> </li> 
 <li>evaluates the moves, selecting the most promising.</li> 
</ul> 
<h3> <a id="user-content-evaluator" class="anchor" href="#evaluator" aria-hidden="true"><span class="octicon octicon-link"></span></a>Evaluator</h3> 
<p>Provides an evaluation of a given position.</p> 
<ul> 
 <li>Counts pieces of each side on the board by value (e.g. queen = 9, rook = 5 etc) - </li> 
 <li>returns the difference between the sides to indicate whether white or black is &quot;winning&quot;.</li> 
</ul> 
<h3> <a id="user-content-position" class="anchor" href="#position" aria-hidden="true"><span class="octicon octicon-link"></span></a>Position</h3> 
<p>Represents a particular arrangement of pieces on the chessboard as a collection of <code>Piece</code>s, providing a list of possible legal moves and other information for evaluation.</p> 
<ul> 
 <li>Generates all possible legal moves from the current position.</li> 
</ul> 
<h3> <a id="user-content-piece" class="anchor" href="#piece" aria-hidden="true"><span class="octicon octicon-link"></span></a>Piece</h3> 
<p>Represents a type of piece (e.g. ROOK) and generates moves and other information for evaluation</p> 
<ul> 
 <li>Generates possible moves for the piece</li> 
 <li>Represents piece occupancy as a bitboard</li> 
</ul> 
<p>See below for more specific information for each piece type.</p> 
<h3> <a id="user-content-move" class="anchor" href="#move" aria-hidden="true"><span class="octicon octicon-link"></span></a>Move</h3> 
<p>Data structure which stores information about a move</p> 
<ul> 
 <li>Origin square</li> 
 <li>Target square</li> 
 <li>Whether the move results in a pawn promotion, and if so which piece is the result {none, queen, rook, bishop, knight}</li> 
 <li>Whether move results in a capture</li> 
 <li>Whether move results in check</li> 
 <li>Whether move results in checkmate</li> 
 <li>Whether move is a special move: {none, double pawn push, en passant, king castle, queen castle}</li> 
 <li>Piece type that moved</li> 
 <li>get the move in algebraic notation as a string </li> 
 <li>get the move in coordinate notation as a string</li> 
</ul> 
<h3> <a id="user-content-xboard-commands" class="anchor" href="#xboard-commands" aria-hidden="true"><span class="octicon octicon-link"></span></a>XBoard commands</h3> 
<h4> <a id="user-content-from-xboard-to-engine" class="anchor" href="#from-xboard-to-engine" aria-hidden="true"><span class="octicon octicon-link"></span></a>From XBoard to engine</h4> 
<table> 
 <thead> 
  <tr> 
   <th>Command</th> 
   <th>Result</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td><code>xboard</code></td> 
   <td>Sent at start of engine process; if not received engine quits in error</td> 
  </tr> 
  <tr> 
   <td> <code>protover</code> <em>N</em> </td> 
   <td> <code>protocol_mode = 1</code> by default, but if this is sent <code>protocol_mode = N</code> and the engine will reply with a <code>feature</code> command.</td> 
  </tr> 
  <tr> 
   <td><code>new</code></td> 
   <td>engine sets board to standard position, with white to move and engine playing black, with time controls reset. Do not ponder even if pondering on, reset search depth.</td> 
  </tr> 
  <tr> 
   <td><code>variant</code></td> 
   <td>not supported, engine replies with error message</td> 
  </tr> 
  <tr> 
   <td><code>quit</code></td> 
   <td>engine cleans up and exits</td> 
  </tr> 
  <tr> 
   <td><code>force</code></td> 
   <td>set force mode, with engine playing neither colour. Moves should be checked for legality but no thinking, pondering or movemaking should be done.</td> 
  </tr> 
  <tr> 
   <td><code>go</code></td> 
   <td>Leave force mode, engine plays colour on move, start clock. Begin thinking.</td> 
  </tr> 
  <tr> 
   <td><code>playother</code></td> 
   <td>(protocol level 2), set engine to play colour not on move, start opponents clock.</td> 
  </tr> 
  <tr> 
   <td><code>MOVE</code></td> 
   <td>sent when opponent performs a move. Check legality of move, update board. If not in force mode, stop oppo clock, start own clock and thinking, and make a move.</td> 
  </tr> 
  <tr> 
   <td><code>usermove MOVE</code></td> 
   <td>same as above, but must be enabled as a feature</td> 
  </tr> 
  <tr> 
   <td><code>?</code></td> 
   <td>move now</td> 
  </tr> 
  <tr> 
   <td><code>ping N</code></td> 
   <td>after other commands have been processed, reply with <code>pong N</code>, where N is the same decimal number.</td> 
  </tr> 
  <tr> 
   <td>result RESULT {COMMENT}</td> 
   <td>End game.</td> 
  </tr> 
  <tr> 
   <td>setboard FEN</td> 
   <td>set board to FEN position (enabled in features)</td> 
  </tr> 
  <tr> 
   <td><code>edit</code></td> 
   <td>put engine in 'edit' mode, where subcommands (below) are enabled.</td> 
  </tr> 
  <tr> 
   <td><code>c</code></td> 
   <td>Edit mode: change colour.</td> 
  </tr> 
  <tr> 
   <td><code>Pa4</code></td> 
   <td>Edit mode: place pawn of current colour on a4</td> 
  </tr> 
  <tr> 
   <td><code>xa4</code></td> 
   <td>Edit mode: clear a4</td> 
  </tr> 
  <tr> 
   <td><code>#</code></td> 
   <td>Edit mode: clear board</td> 
  </tr> 
  <tr> 
   <td><code>.</code></td> 
   <td>Edit mode: leave edit mode.</td> 
  </tr> 
  <tr> 
   <td><code>hint</code></td> 
   <td>no-op (send hint)</td> 
  </tr> 
  <tr> 
   <td><code>bk</code></td> 
   <td>send back &quot;Not supported&quot;</td> 
  </tr> 
  <tr> 
   <td><code>undo</code></td> 
   <td>go back a move</td> 
  </tr> 
  <tr> 
   <td><code>remove</code></td> 
   <td>undo two moves and continue playing same colour</td> 
  </tr> 
  <tr> 
   <td><code>pause/resume</code></td> 
   <td>pause/resume any thinking/pondering and stop clocks</td> 
  </tr> 
 </tbody> 
</table> 
<h5> <a id="user-content-no-op-commands" class="anchor" href="#no-op-commands" aria-hidden="true"><span class="octicon octicon-link"></span></a>No-op commands</h5> 
<p>These are recognised as valid commands, but don't actually do anything in the engine (currently) Command | Result ------------------------|-------- <code>draw</code> | no-op (opponent offers draw, this engine fights to the death!) <code>accepted</code>|<code>rejected</code> | no-op <code>random</code> | no-op <code>level MPS BASE INC</code> | no-op (set time controls) <code>st TIME</code> | no-op (set time) <code>sd DEPTH</code> | no-op (limit depth) <code>nps NODE_RATE</code> | no-op (limit nodes searched) <code>hard</code> | no-op (turn on thinking/pondering) <code>easy</code> | no-op (turn off thinking/pondering) <code>post</code> | no-op (turn on thinking/pondering output) <code>nopost</code> | no-op (turn off thinking/pondering output) <code>analyze</code> | no-op (turn on analyse mode) <code>name X</code> | no-op (inform engine of opponent name) <code>rating</code> | no-op (in ICS mode, send opponent rating) <code>ics HOSTNAME</code> | no-op (whether engine is playing a local user or an ICS server) <code>computer</code> | no-op (opponent is another computer engine) <code>memory N</code> | no-op (inform engine of how much memory in N megabytes it can use) <code>cores N</code> | no-op (number of cores engine can use) <code>egtpath TYPE PATH</code> | no-op (where endgame databases can be found) <code>exclude MOVE</code>,<code>include MOVE</code>,<code>exclude all</code>,<code>include all</code>| no-op (exclude/include specified moves) <code>setscore SCORE DEPTH</code> | no-op <code>lift SQUARE</code>,<code>put SQUARE</code>,<code>hover SQUARE</code>| no-op <code>option NAME[=VALUE]</code> | no-op (changes the value of a user-defined option)</p> 
<h4> <a id="user-content-from-engine-to-xboard" class="anchor" href="#from-engine-to-xboard" aria-hidden="true"><span class="octicon octicon-link"></span></a>From engine to XBoard</h4> 
<table> 
 <thead> 
  <tr> 
   <th>Command</th> 
   <th>Sent when</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td> <code>feature</code><code>FEATURE1=VALUE1</code> <code>FEATURE2=VALUE2</code> etc</td> 
   <td>At beginning of game, with [ping=1, playother=1, setboard=1, myname=BitChess, variants=normal, reuse=0, colors=0, analyze=0, nps=0]</td> 
  </tr> 
  <tr> 
   <td><code>Illegal move (REASON): MOVE</code></td> 
   <td>if engine receives a move that is a move but not legal in current position, e.g. <code>Illegal move: e2e4;Illegal move (in check): Nf3; Illegal move (moving into check): e1g1</code>.</td> 
  </tr> 
  <tr> 
   <td><code>Error (ERRORTYPE): COMMAND</code></td> 
   <td>if a command is received that the engine does not understand or implement, e.g. <code>Error (ambiguous move): Nf3,Error (unknown command): analyze,Error (command not legal now): undo,Error (too many parameters): level 1 2 3 4 5 6 7</code> </td> 
  </tr> 
  <tr> 
   <td><code>move MOVE</code></td> 
   <td>Make a move chosen by the engine</td> 
  </tr> 
  <tr> 
   <td><code>RESULT {COMMENT}</code></td> 
   <td>Checkmate/stalemate is detected by the engine</td> 
  </tr> 
 </tbody> 
</table> 
<h5> <a id="user-content-non-implemented-commands" class="anchor" href="#non-implemented-commands" aria-hidden="true"><span class="octicon octicon-link"></span></a>Non implemented commands</h5> 
<table> 
 <thead> 
  <tr> 
   <th>Command</th> 
   <th>Sent when</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td><code>resign</code></td> 
   <td>not implem(engine fights to the death)</td> 
  </tr> 
  <tr> 
   <td><code>offer draw</code></td> 
   <td>not implem (engine fights to the death)</td> 
  </tr> 
  <tr> 
   <td><code>tellopponent MESSAGE</code></td> 
   <td>not implem</td> 
  </tr> 
  <tr> 
   <td><code>tellothers MESSAGE</code></td> 
   <td>not implem</td> 
  </tr> 
  <tr> 
   <td><code>tellall MESSAGE</code></td> 
   <td>not implem</td> 
  </tr> 
  <tr> 
   <td><code>telluser MESSAGE</code></td> 
   <td>not implem</td> 
  </tr> 
  <tr> 
   <td><code>tellusererror MESSAGE</code></td> 
   <td>not implem</td> 
  </tr> 
  <tr> 
   <td><code>askuser REPTAG MESSAGE</code></td> 
   <td>not implem</td> 
  </tr> 
  <tr> 
   <td><code>tellicsnoalias MESSAGE</code></td> 
   <td>not implem</td> 
  </tr> 
  <tr> 
   <td><code># COMMENT</code></td> 
   <td>not implem</td> 
  </tr> 
 </tbody> 
</table> 
<h2> <a id="user-content-implementation" class="anchor" href="#implementation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Implementation</h2> 
<h3> <a id="user-content-xboardctrl-1" class="anchor" href="#xboardctrl-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>XBoardCtrl</h3> 
<ul> 
 <li> <p><code>XBoardCtrl(istream in, ostream out)</code>:</p> 
  <ul> 
   <li>constructs the class, using the given input and output streams for I/O.</li> 
   <li>Checks whether the streams are open, throws an exception if not</li> 
   <li>Sends a list of features to enable/disable on <code>out</code> </li> 
  </ul> </li> 
 <li> <p><code>map&lt;string, function&gt; command_map</code>:</p> 
  <ul> 
   <li>is a function lookup table for all relevant xboard commands. Each function has the call signature <code>void f(vector&lt;string&gt;)</code> </li> 
  </ul> </li> 
 <li> <p><code>parse_command(string commandstr)</code>:</p> 
  <ul> 
   <li>ignores empty commandstr</li> 
   <li>splits the <code>commandstr</code> by spaces to get command and optional parameters</li> 
   <li>if no spaces, whole <code>commandstr</code> is the command</li> 
   <li>looks up the command in <code>command_map</code> </li> 
   <li>and passes a <code>vector&lt;string&gt;</code> of parameters to the function</li> 
  </ul> </li> 
 <li> <p><code>poll()</code>:</p> 
  <ul> 
   <li>Polls <code>stdin</code> for input</li> 
   <li>If input received, wait for a <code>\n</code> and pass to <code>parse_command</code> </li> 
   <li>Else pass control back to the calling function</li> 
   <li>Passed as a callback function to the <code>Game</code> component</li> 
  </ul> </li> 
</ul> 
<h3> <a id="user-content-game-1" class="anchor" href="#game-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Game</h3> 
<ul> 
 <li> <code>Game::Game(polling_function)</code>: 
  <ul> 
   <li> <code>polling_function</code> is called regularly to poll for input</li> 
  </ul> </li> 
 <li> <code>current_position</code> with getter and setter</li> 
 <li><code>private Searcher searcher</code></li> 
 <li> <code>Move Game::get_next_move()</code>: 
  <ul> 
   <li><code>return searcher.get_next_move(current_position,side_to_move);</code></li> 
  </ul> </li> 
 <li> <code>void Game::do_oppo_move(Move move)</code>: 
  <ul> 
   <li>update <code>current_position</code> </li> 
   <li>add <code>move</code> to <code>moves_list</code> </li> 
   <li>TODO: engine turn logic</li> 
  </ul> </li> 
</ul> 
<h3> <a id="user-content-searcher-1" class="anchor" href="#searcher-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Searcher</h3> 
<ul> 
 <li><code>Searcher::Searcher()</code></li> 
 <li><code>private Evaluator evaluator</code></li> 
 <li> <code>Move Searcher::get_next_move(Position position,side_to_move)</code> 
  <ul> 
   <li> <code>evaluator.evaluate(position)</code> </li> 
   <li>loop through <code>position.get_all_legal_moves(side_to_move)</code> 
    <ul> 
     <li>create next position with <code>position.with_move(move)</code> </li> 
     <li>evaluate position and add to results (with, e.g. <code>pair&lt;float,Move&gt;</code>)</li> 
    </ul> </li> 
   <li>sort results</li> 
   <li>choose move with best evaluation</li> 
  </ul> </li> 
</ul> 
<h3> <a id="user-content-evaluator-1" class="anchor" href="#evaluator-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Evaluator</h3> 
<ul> 
 <li> <p><code>float Evaluator::evaluate(Position position, side_to_move)</code>:</p> 
  <ul> 
   <li><p><code>map&lt;piece_type,int&gt; counts = position.get_piece_counts()</code></p></li> 
   <li> <p>loop through pieces in <code>counts[side_to_move]</code></p> 
    <ul> 
     <li>multiply piece count by piece multiplier</li> 
     <li> <code>eval_side_to_move =</code>summation</li> 
    </ul> </li> 
   <li> <code>eval_other_side</code> = repeat for other side</li> 
   <li><code>return eval_side_to_move - eval_other_side</code></li> 
  </ul> </li> 
</ul> 
<h3> <a id="user-content-position-1" class="anchor" href="#position-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Position</h3> 
<ul> 
 <li> <code>map&lt;side,map&lt;piece_type,Piece&gt;&gt; map_pieces</code> 
  <ul> 
   <li>stores pieces in map, e.g. to access black queen = <code>map_pieces[black][queen]</code> </li> 
  </ul> </li> 
 <li> <code>array&lt;piece*, 64&gt; array_pieces</code> 
  <ul> 
   <li>stores pointers to the same pieces in their board locations or to the piece type <code>PIECE_NONE</code> </li> 
  </ul> </li> 
 <li> <code>map&lt;piece_type,int&gt; position.get_piece_counts()</code> 
  <ul> 
   <li>Loop through pieces in maps: 
    <ul> 
     <li>assign <code>map_pieces[side][piece].occupancy.count()</code> to a <code>map&lt;piece_type,int&gt;</code>and return it</li> 
    </ul> </li> 
  </ul> </li> 
 <li> <code>vector&lt;Move&gt; get_all_legal_moves(side_to_move)</code> 
  <ul> 
   <li>Loop through pieces of <code>side_to_move</code>: 
    <ul> 
     <li>append all moves from <code>piece.get_pseudolegal_moves()</code> </li> 
    </ul> </li> 
   <li>TODO: <code>test_checks(move_list)</code> check moves for checks on own or opposite king 
    <ul> 
     <li>remove any resulting in check on own king (illegal)</li> 
     <li>set <code>check=true</code> flag to any resulting in check on opp king</li> 
    </ul> </li> 
  </ul> </li> 
</ul> 
<h3> <a id="user-content-piece-1" class="anchor" href="#piece-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Piece</h3> 
<ul> 
 <li><code>Piece::Piece()</code></li> 
 <li> <code>Piece::Piece(int initial_square)</code> 
  <ul> 
   <li>Initialise occupancy with initial_square set</li> 
  </ul> </li> 
 <li> <code>bitboard occupancy</code> 
  <ul> 
   <li>contains occupancy info on bitboard (1 represents occupancy)</li> 
  </ul> </li> 
 <li> <code>virtual vector&lt;Move&gt; get_legal_moves()</code> 
  <ul> 
   <li>implemented by subclasses to calculate possible moves</li> 
  </ul> </li> 
</ul> 
<h3> <a id="user-content-move-1" class="anchor" href="#move-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Move</h3> 
<p>Data structure which stores information about a move</p> 
<ul> 
 <li><code>short sq_origin</code></li> 
 <li><code>short sq_target</code></li> 
 <li><code>promotion_type promotion</code></li> 
 <li><code>bool is_capture</code></li> 
 <li><code>bool is_check</code></li> 
 <li><code>bool is_checkmate</code></li> 
 <li> <code>spec_move_type special_move</code>: </li> 
 <li>piece_type piece</li> 
 <li><code>string get_in_algebraic()</code></li> 
 <li><code>string get_in_coordinate()</code></li> 
 <li><code>enum promotion_type {NONE, QUEEN, ROOK, KNIGHT,BISHOP}</code></li> 
 <li><code>enum spec_move_type {NONE, DOUBLE_PAWN_PUSH, EN_PASSANT, CASTLE_KING, CASTLE_QUEEN}</code></li> 
</ul> 
<h3> <a id="user-content-bitboard" class="anchor" href="#bitboard" aria-hidden="true"><span class="octicon octicon-link"></span></a>Bitboard</h3> 
<p>Currently just <code>typedef bitset&lt;64&gt; bitboard</code>. Shift operations defined separately; alternatively could extend <code>bitset&lt;64&gt;</code> class to include these</p> 
<h3> <a id="user-content-global-constsenums" class="anchor" href="#global-constsenums" aria-hidden="true"><span class="octicon octicon-link"></span></a>Global consts/enums</h3> 
<p><code>enum side {WHITE, BLACK}</code> <code>enum piece_type {ROOK,KNIGHT,BISHOP,QUEEN,KING,PAWN,NONE}</code></p> 
<h3> <a id="user-content-piece-subclasses" class="anchor" href="#piece-subclasses" aria-hidden="true"><span class="octicon octicon-link"></span></a>Piece subclasses</h3> 
<h4> <a id="user-content-piecenone" class="anchor" href="#piecenone" aria-hidden="true"><span class="octicon octicon-link"></span></a>PieceNone</h4> 
<p>Indicates an empty square.</p> 
<ul> 
 <li> <code>vector&lt;Move&gt; get_pseudolegal_moves()</code> 
  <ul> 
   <li>returns empty vector</li> 
  </ul> </li> 
</ul> 
<h4> <a id="user-content-rook" class="anchor" href="#rook" aria-hidden="true"><span class="octicon octicon-link"></span></a>Rook</h4> 
<ul> 
 <li> <code>vector&lt;Move&gt; get_pseudolegal_moves()</code> 
  <ul> 
   <li> bitscan to get squares of rooks</li> 
   <li>loop through squares 
    <ul> 
     <li><code>moves = get_file_attacks(occupancy,sq) &amp; own_occupancy</code></li> 
     <li>bitscan <code>moves</code> to get move target squares</li> 
     <li>create &amp; append moves, with origin=rook sq, target = target squares</li> 
     <li><code>possible_captures = moves &amp; opp_occupancy</code></li> 
    </ul> </li> 
  </ul> </li> 
</ul> 
<h4> <a id="user-content-bishop" class="anchor" href="#bishop" aria-hidden="true"><span class="octicon octicon-link"></span></a>Bishop</h4> 
<ul> 
 <li> <code>vector&lt;Move&gt; get_pseudolegal_moves()</code> 
  <ul> 
   <li> Similar process for Rook, except <code>get_bishop_attacks</code> is used instead</li> 
  </ul> </li> 
</ul> 
<h4> <a id="user-content-queen" class="anchor" href="#queen" aria-hidden="true"><span class="octicon octicon-link"></span></a>Queen</h4> 
<ul> 
 <li> <code>vector&lt;Move&gt; get_pseudolegal_moves()</code> 
  <ul> 
   <li> Similar process, combining both Rook and Bishop <code>get_psuedolegal_moves()</code> </li> 
  </ul> </li> 
</ul> 
<h4> <a id="user-content-king" class="anchor" href="#king" aria-hidden="true"><span class="octicon octicon-link"></span></a>King</h4> 
<ul> 
 <li> <code>vector&lt;Move&gt; get_pseudolegal_moves()</code> 
  <ul> 
   <li> <code>vanilla_moves = move_lookup[king][square]</code> </li> 
   <li>Get possible knight moves from a precalculated lookup table.</li> 
   <li><code>possible_checks = vanilla_moves &amp; opp[king].occupancy</code></li> 
   <li> <code>possible_captures = vanilla_moves &amp; opp_occupancy</code> 
    <ul> 
     <li>Get possible captures with the union of possible moves and opponent occupancy (can only capture opponents)</li> 
     <li>bitscan <code>possible_captures</code>: array of <code>target_squares</code> 
      <ul> 
       <li>create &amp; append new <code>Move</code> with capture=<code>true</code>, origin = <code>square</code> and <code>target_square</code> </li> 
      </ul> </li> 
    </ul> </li> 
   <li> <code>possible_moves = vanilla_moves &amp; ~own_occupancy &amp; ~captures</code> 
    <ul> 
     <li>Get other moves with union of squares not occupied by own pieces (complement of own_occupancy) and complement of captures to avoid double counting moves 
      <ul> 
       <li>create &amp; append new Move with origin = <code>square</code> and <code>target_square</code> </li> 
      </ul> </li> 
    </ul> </li> 
   <li>TODO: <code>test_checks(move_list)</code> check moves for checks on own or opposite king 
    <ul> 
     <li>remove any resulting in check on own king (illegal)</li> 
     <li>set <code>check=true</code> flag to any resulting in check on opp king ####Knight</li> 
    </ul> </li> 
  </ul> </li> 
 <li> <code>vector&lt;Move&gt; get_pseudolegal_moves()</code> 
  <ul> 
   <li>bitscan occupancy to get knight occupied squares</li> 
   <li>loop through squares 
    <ul> 
     <li> <code>vanilla_moves = move_lookup[knight][square]</code> 
      <ul> 
       <li>Get possible knight moves from a precalculated lookup table.</li> 
      </ul> </li> 
     <li><code>possible_checks = vanilla_moves &amp; opp[king].occupancy</code></li> 
     <li> <code>possible_captures = vanilla_moves &amp; opp_occupancy</code> 
      <ul> 
       <li>Get possible captures with the union of possible moves and opponent occupancy (can only capture opponents)</li> 
       <li>bitscan <code>possible_captures</code>: array of <code>target_squares</code> 
        <ul> 
         <li>create &amp; append new <code>Move</code> with capture=<code>true</code>, origin = <code>square</code> and <code>target_square</code> </li> 
        </ul> </li> 
      </ul> </li> 
     <li> <code>possible_moves = vanilla_moves &amp; ~own_occupancy &amp; ~captures</code> 
      <ul> 
       <li>Get other moves with union of squares not occupied by own pieces (complement of own_occupancy) and complement of captures to avoid double counting moves 
        <ul> 
         <li>create &amp; append new Move with origin = <code>square</code> and <code>target_square</code> </li> 
        </ul> </li> 
       <li> ####Pawn</li> 
      </ul> </li> 
    </ul> </li> 
  </ul> </li> 
 <li> <p><code>vector&lt;Move&gt; get_pseudolegal_moves()</code></p> 
  <ul> 
   <li> <code>single_moves = shift(own pawn occupancy) &amp; ~own_occupancy &amp; ~opp_occupancy</code> 
    <ul> 
     <li> <code>end_rank_mask</code> excludes pawns pushing for promotion</li> 
     <li> where shift= north for white and south for black</li> 
     <li>checks pawns do not clash with pieces on square in front</li> 
    </ul> </li> 
   <li> <code>double_moves = shift(own_pawn_occupancy &amp; double_pawn_mask[side]) &amp; ~own_occupancy &amp; ~opp_occupancy</code> 
    <ul> 
     <li>as above but applies mask to restrict to pawns that have not moved yet</li> 
     <li>create &amp; append <code>Move::create_double_pawn_move(origin,target)</code> for each bit</li> 
    </ul> </li> 
   <li> <code>captures = (shift_diagonal(own pawn occupancy) &amp; opp_occupancy) | (shift_diagonal(own pawn occupancy) &amp; en_passant)</code> 
    <ul> 
     <li>shift diagonal shifts all pawns forward and to left/right</li> 
     <li>union with opponent pieces to show captures</li> 
     <li>if any en passant captures are available show them</li> 
    </ul> </li> 
   <li> <code>promotions = single_moves &amp; back_rank_mask</code> 
    <ul> 
     <li>also do <code>single_moves -= promotions</code> to exclude duplicates</li> 
     <li>append <code>promotion_moves(sq, capture=false)</code> which will create vector of moves with possible promotion options (queen,rook etc).</li> 
    </ul> </li> 
   <li> <p><code>promotion_captures = captures &amp; back_rank_mask</code></p> 
    <ul> 
     <li>again <code>single_moves -= promotion_captures</code> </li> 
     <li>append `promotion_moves(sq, capture=true)</li> 
    </ul> </li> 
   <li><p>now create &amp; append moves for <code>single_moves</code></p></li> 
  </ul> </li> 
</ul>
</body>
</html>
